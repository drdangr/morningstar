{
  "name": "telegram_digest_workflow_v7.1_fixed_ai_prompts",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "telegram-posts",
        "options": {}
      },
      "name": "Webhook - Receive Posts",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [
        -120,
        0
      ],
      "id": "57a69352-58fb-47df-b219-012767c8d01e",
      "webhookId": "telegram-posts-webhook"
    },
    {
      "parameters": {
        "functionCode": "// –ü–æ–ª—É—á–µ–Ω–∏–µ –∏ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –æ—Ç userbot —Å –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ–º webhook —Å—Ç—Ä—É–∫—Ç—É—Ä—ã\nconst rawData = $json;\nconsole.log('üì• Raw webhook data received:', JSON.stringify(rawData, null, 2));\n\n// –ò—Å–ø—Ä–∞–≤–ª—è–µ–º —Å—Ç—Ä—É–∫—Ç—É—Ä—É –¥–∞–Ω–Ω—ã—Ö webhook (body vs direct)\nconst data = rawData.body || rawData;\nconsole.log('üìä Processing data structure...');\n\nif (!data) {\n    console.log('‚ùå No data found in webhook');\n    return { error: 'No data received', timestamp: new Date().toISOString() };\n}\n\nconst posts = data.posts || [];\nconst channelsMetadata = data.channels_metadata || {};\nconst collectionStats = data.collection_stats || {};\n\nconsole.log(`üìà Received: ${posts.length} posts from ${Object.keys(channelsMetadata).length} channels`);\nconsole.log('üìã Collection stats:', collectionStats);\n\nif (posts.length === 0) {\n    console.log('‚ö†Ô∏è No posts to process');\n    return {\n        posts: [],\n        channels_metadata: channelsMetadata,\n        collection_stats: collectionStats,\n        timestamp: new Date().toISOString(),\n        has_posts: false\n    };\n}\n\nconsole.log('‚úÖ Posts processed successfully');\nreturn {\n    posts: posts,\n    channels_metadata: channelsMetadata,\n    collection_stats: collectionStats,\n    timestamp: new Date().toISOString(),\n    has_posts: true\n};"
      },
      "name": "Process & Log Data",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        100,
        0
      ],
      "id": "f62f985d-92c3-4c76-bf4f-e7b333f885a3"
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.has_posts }}",
              "value2": true
            }
          ]
        }
      },
      "name": "Has Posts?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [
        320,
        0
      ],
      "id": "6dfa77bc-d78a-4aeb-9d78-346a38edb1e2"
    },
    {
      "parameters": {
        "functionCode": "// –ì—Ä—É–ø–ø–∏—Ä–æ–≤–∫–∞ –ø–æ—Å—Ç–æ–≤ –ø–æ –∫–∞–Ω–∞–ª–∞–º —Å —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ–º –º–µ—Ç–∞–¥–∞–Ω–Ω—ã—Ö\nconst data = $json;\nconst posts = data.posts || [];\nconst channelsMetadata = data.channels_metadata || {};\n\nconsole.log('üìä Grouping posts by channels...');\nconsole.log('üìã Available channels metadata:', Object.keys(channelsMetadata));\n\nconst grouped = {};\n\nposts.forEach(post => {\n    const key = post.channel_username || `channel_${post.channel_id}`;\n    \n    if (!grouped[key]) {\n        grouped[key] = {\n            channel_id: post.channel_id,\n            channel_username: post.channel_username,\n            channel_title: post.channel_title,\n            posts: [],\n            categories: channelsMetadata[post.channel_username]?.categories || []\n        };\n    }\n    \n    grouped[key].posts.push(post);\n});\n\nconst result = {\n    timestamp: data.timestamp,\n    stats: data.collection_stats,\n    grouped_posts: grouped,\n    channels_metadata: channelsMetadata\n};\n\nconsole.log(`üìà Grouped into ${Object.keys(grouped).length} channels`);\nObject.keys(grouped).forEach(key => {\n    const channel = grouped[key];\n    console.log(`  üì∫ ${channel.channel_title}: ${channel.posts.length} posts, ${channel.categories.length} categories`);\n});\n\nreturn result;"
      },
      "name": "Group by Channels",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        540,
        0
      ],
      "id": "7cbddbbb-0fb9-4ba8-9264-893422fa44c0"
    },
    {
      "parameters": {
        "functionCode": "// –ò–°–ü–†–ê–í–õ–ï–ù–û v7.1: –ü—Ä–∞–≤–∏–ª—å–Ω–æ–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ description –∏ ai_prompt\nconsole.log('ü§ñ Preparing data for OpenAI with FIXED AI prompts v7.1...');\n\nconst groupedPostsData = $json;\nconst groupedPosts = groupedPostsData.grouped_posts || {};\nconst channelsMetadata = groupedPostsData.channels_metadata || {};\n\nconsole.log(`üìã Found grouped posts for ${Object.keys(groupedPosts).length} channels`);\nconsole.log('üìã Channels metadata available:', Object.keys(channelsMetadata));\n\n// –°–æ–±–∏—Ä–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –ø–æ Many-to-Many —Å–≤—è–∑—è–º –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –∫–∞–Ω–∞–ª–∞\nconst channelCategoryMap = {};\nconst categoryDescriptions = {};  // –ò–°–ü–†–ê–í–õ–ï–ù–û: –æ—Ç–¥–µ–ª—å–Ω–æ descriptions\nconst categoryAIPrompts = {};     // –ò–°–ü–†–ê–í–õ–ï–ù–û: –æ—Ç–¥–µ–ª—å–Ω–æ AI –ø—Ä–æ–º–ø—Ç—ã\nlet allActiveCategories = new Set();\n\nObject.keys(groupedPosts).forEach(channelKey => {\n    const channelData = groupedPosts[channelKey];\n    const channelUsername = channelData.channel_username;\n    \n    console.log(`üìã –ö–∞–Ω–∞–ª: ${channelData.channel_title} (${channelUsername})`);\n    \n    // –ò—Å–ø–æ–ª—å–∑—É–µ–º –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –ø—Ä—è–º–æ –∏–∑ grouped –¥–∞–Ω–Ω—ã—Ö –∏–ª–∏ –º–µ—Ç–∞–¥–∞–Ω–Ω—ã—Ö\n    const categories = channelData.categories || channelsMetadata[channelUsername]?.categories || [];\n    const activeCategories = categories.filter(cat => cat.is_active);\n    \n    channelCategoryMap[channelUsername] = activeCategories;\n    \n    activeCategories.forEach(category => {\n        allActiveCategories.add(category.name);\n        \n        // –ò–°–ü–†–ê–í–õ–ï–ù–û: –ü—Ä–∞–≤–∏–ª—å–Ω–æ —Ä–∞–∑–¥–µ–ª—è–µ–º description –∏ ai_prompt\n        if (category.description) {\n            categoryDescriptions[category.name] = category.description;\n        }\n        if (category.ai_prompt) {\n            categoryAIPrompts[category.name] = category.ai_prompt;\n        }\n        \n        console.log(`  üè∑Ô∏è –ê–∫—Ç–∏–≤–Ω–∞—è –∫–∞—Ç–µ–≥–æ—Ä–∏—è: ${category.name}`);\n        console.log(`    üìù Description: ${category.description?.substring(0, 80)}...`);\n        console.log(`    ü§ñ AI prompt: ${category.ai_prompt?.substring(0, 80)}...`);\n    });\n    \n    if (activeCategories.length === 0) {\n        console.log(`  ‚ö†Ô∏è –ù–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö –∫–∞—Ç–µ–≥–æ—Ä–∏–π –¥–ª—è ${channelUsername}`);\n    }\n});\n\n// –§–æ—Ä–º–∏—Ä—É–µ–º —Å–ø–∏—Å–æ–∫ –∫–∞—Ç–µ–≥–æ—Ä–∏–π –¥–ª—è OpenAI\nconst categories = Array.from(allActiveCategories);\n\nconsole.log(`‚úÖ FIXED v7.1: –ù–∞–π–¥–µ–Ω–æ ${categories.length} —É–Ω–∏–∫–∞–ª—å–Ω—ã—Ö –∞–∫—Ç–∏–≤–Ω—ã—Ö –∫–∞—Ç–µ–≥–æ—Ä–∏–π:`, categories);\nconsole.log('üîó –°–≤—è–∑–∏ –∫–∞–Ω–∞–ª–æ–≤ —Å –∫–∞—Ç–µ–≥–æ—Ä–∏—è–º–∏:');\nObject.keys(channelCategoryMap).forEach(channel => {\n    const cats = channelCategoryMap[channel].map(c => c.name).join(', ');\n    console.log(`  ${channel} ‚Üí [${cats}]`);\n});\n\n// –ü–æ–¥–≥–æ—Ç–∞–≤–ª–∏–≤–∞–µ–º –ø–æ—Å—Ç—ã –¥–ª—è AI –∞–Ω–∞–ª–∏–∑–∞\nconst postsForAI = [];\n\nObject.keys(groupedPosts).forEach(channelKey => {\n    const channelData = groupedPosts[channelKey];\n    \n    channelData.posts.forEach(post => {\n        if (post.text && post.text.length > 50) {\n            postsForAI.push({\n                id: post.id,\n                text: post.text.substring(0, 1000),\n                channel: channelData.channel_title,\n                channel_username: channelData.channel_username,\n                views: post.views || 0,\n                date: post.date,\n                url: post.url,\n                // –î–æ–±–∞–≤–ª—è–µ–º —Å–≤—è–∑–∞–Ω–Ω—ã–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –∫–∞–Ω–∞–ª–∞\n                channel_categories: channelCategoryMap[channelData.channel_username]?.map(c => c.name) || []\n            });\n        }\n    });\n});\n\nconsole.log(`üìù Prepared ${postsForAI.length} posts for AI analysis`);\n\n// –ò–°–ü–†–ê–í–õ–ï–ù–û: –§–æ—Ä–º–∏—Ä—É–µ–º —Å–ø–∏—Å–æ–∫ —Ç–µ–º –∏—Å–ø–æ–ª—å–∑—É—è DESCRIPTION, –∞ –Ω–µ ai_prompt\nconst topicsDescription = categories.map(cat => {\n    const description = categoryDescriptions[cat] || cat; // –ò–°–ü–†–ê–í–õ–ï–ù–û: –∏—Å–ø–æ–ª—å–∑—É–µ–º description\n    return `${cat} (${description})`;\n}).join(', ');\n\n// –ò–°–ü–†–ê–í–õ–ï–ù–û: –°–æ–±–∏—Ä–∞–µ–º –∫–∞—Å—Ç–æ–º–Ω—ã–µ AI –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏ –æ—Ç–¥–µ–ª—å–Ω–æ\nconst customInstructions = Object.values(categoryAIPrompts)\n    .filter(prompt => prompt && prompt.length > 0)\n    .join(' ');\n\n// –ò–°–ü–†–ê–í–õ–ï–ù–û: –ù–æ–≤—ã–π –ø—Ä–æ–º–ø—Ç —Å –ø—Ä–∞–≤–∏–ª—å–Ω—ã–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –ø–æ–ª–µ–π\nconst baseDynamicPrompt = `–û—Ç—Ñ–∏–ª—å—Ç—Ä—É–π –ø–æ—Å—Ç—ã –ø–æ —Ç–µ–º–µ: ${topicsDescription}.\\n\\n–ü—Ä–∞–≤–∏–ª–æ: summary = \\\"NULL\\\" –µ—Å–ª–∏ —Ç–µ–∫—Å—Ç –ø–æ—Å—Ç–∞ –ù–ï –∏–º–µ–µ—Ç –æ—Ç–Ω–æ—à–µ–Ω–∏—è –ù–ò –ö –û–î–ù–û–ô –∏–∑ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–Ω—ã—Ö —Ç–µ–º.\\n\\n–î–ª—è –∫–∞–∂–¥–æ–≥–æ –ø–æ—Å—Ç–∞:\\n\\n–ï–°–õ–ò –ø–æ—Å—Ç –∏–º–µ–µ—Ç –æ—Ç–Ω–æ—à–µ–Ω–∏–µ –∫ —Ç–µ–º–µ - –¥–∞–π –∫—Ä–∞—Ç–∫–æ–µ —Ä–µ–∑—é–º–µ + –º–µ—Ç—Ä–∏–∫–∏ 1-10.\\n–ï–°–õ–ò –ø–æ—Å—Ç –ù–ï –∏–º–µ–µ—Ç –æ—Ç–Ω–æ—à–µ–Ω–∏—è –∫ —Ç–µ–º–∞–º - –Ω–∞–ø–∏—à–∏ \\\"NULL\\\" + –º–µ—Ç—Ä–∏–∫–∏ 0.\\n\\n–í–æ–∑–≤—Ä–∞—â–∞–π JSON:\\n{\\\"results\\\": [{\\\"id\\\": \\\"post_id\\\", \\\"summary\\\": \\\"—Ä–µ–∑—é–º–µ –∏–ª–∏ NULL\\\", \\\"importance\\\": 8, \\\"urgency\\\": 6, \\\"significance\\\": 7}]}\\n\\n–ê–Ω–∞–ª–∏–∑–∏—Ä—É–π –ø–æ –°–ú–´–°–õ–£, –∞ –Ω–µ —Ç–æ–ª—å–∫–æ –ø–æ –∫–ª—é—á–µ–≤—ã–º —Å–ª–æ–≤–∞–º. –£—á–∏—Ç—ã–≤–∞–π –∫–æ–Ω—Ç–µ–∫—Å—Ç –∏ —Å–µ–º–∞–Ω—Ç–∏–∫—É.`;\n\n// –ò–°–ü–†–ê–í–õ–ï–ù–û: –î–æ–±–∞–≤–ª—è–µ–º –∫–∞—Å—Ç–æ–º–Ω—ã–µ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏ –≤ –∫–æ–Ω–µ—Ü –ø—Ä–æ–º–ø—Ç–∞\nconst dynamicPrompt = customInstructions.length > 0 \n    ? `${baseDynamicPrompt}\\n\\n–î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏: ${customInstructions}`\n    : baseDynamicPrompt;\n\nconsole.log('üîÆ Generated FIXED prompt v7.1 with proper description/ai_prompt separation');\nconsole.log('üìä Categories with descriptions:', Object.keys(categoryDescriptions).length);\nconsole.log('ü§ñ Categories with AI prompts:', Object.keys(categoryAIPrompts).length);\nconsole.log('üìù Custom instructions added:', customInstructions.length > 0);\n\n// FALLBACK —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –≤–æ–æ–±—â–µ –Ω–µ—Ç –∫–∞—Ç–µ–≥–æ—Ä–∏–π\nif (categories.length === 0) {\n    console.log('‚ùå –ö–†–ò–¢–ò–ß–ï–°–ö–ê–Ø –û–®–ò–ë–ö–ê: –ù–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö –∫–∞—Ç–µ–≥–æ—Ä–∏–π, –∏—Å–ø–æ–ª—å–∑—É–µ–º fallback');\n    const fallbackPrompt = `–ê–Ω–∞–ª–∏–∑–∏—Ä—É–π –ø–æ—Å—Ç—ã –∏ –æ–ø—Ä–µ–¥–µ–ª—è–π –∏—Ö —Ä–µ–ª–µ–≤–∞–Ω—Ç–Ω–æ—Å—Ç—å –æ–±—â–∏–º –Ω–æ–≤–æ—Å—Ç–Ω—ã–º —Ç–µ–º–∞–º. –î–ª—è —Ä–µ–ª–µ–≤–∞–Ω—Ç–Ω—ã—Ö –ø–æ—Å—Ç–æ–≤ –¥–∞–≤–∞–π –∫—Ä–∞—Ç–∫–æ–µ —Ä–µ–∑—é–º–µ –∏ –º–µ—Ç—Ä–∏–∫–∏ –≤–∞–∂–Ω–æ—Å—Ç–∏/—Å—Ä–æ—á–Ω–æ—Å—Ç–∏/–∑–Ω–∞—á–∏–º–æ—Å—Ç–∏, –¥–ª—è –Ω–µ—Ä–µ–ª–µ–≤–∞–Ω—Ç–Ω—ã—Ö - \\\"NULL\\\".`;\n    \n    return {\n        timestamp: groupedPostsData.timestamp,\n        stats: groupedPostsData.stats,\n        grouped_posts: groupedPosts,\n        posts_for_ai: postsForAI,\n        total_posts_for_ai: postsForAI.length,\n        dynamic_prompt: fallbackPrompt,\n        categories: ['–û–±—â–∏–µ –Ω–æ–≤–æ—Å—Ç–∏'],\n        channel_category_map: {},\n        error: 'No active categories found'\n    };\n}\n\nreturn {\n    timestamp: groupedPostsData.timestamp,\n    stats: groupedPostsData.stats,\n    grouped_posts: groupedPosts,\n    posts_for_ai: postsForAI,\n    total_posts_for_ai: postsForAI.length,\n    dynamic_prompt: dynamicPrompt,\n    categories: categories,\n    channel_category_map: channelCategoryMap,\n    category_descriptions: categoryDescriptions, // –ò–°–ü–†–ê–í–õ–ï–ù–û: –Ω–æ–≤–æ–µ –ø–æ–ª–µ\n    category_ai_prompts: categoryAIPrompts,      // –ò–°–ü–†–ê–í–õ–ï–ù–û: –Ω–æ–≤–æ–µ –ø–æ–ª–µ\n    binary_relevance: true,\n    with_metrics: true,\n    fixed_ai_prompts: true,                      // –ò–°–ü–†–ê–í–õ–ï–ù–û: —Ñ–ª–∞–≥ –≤–µ—Ä—Å–∏–∏\n    version: 'v7.1_fixed'\n};"
      },
      "name": "Prepare for AI",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        780,
        0
      ],
      "id": "bb1319c3-68a2-42dc-b5e5-3224d26cd196"
    },
    {
      "parameters": {
        "modelId": {
          "__rl": true,
          "value": "gpt-4o-mini",
          "mode": "list",
          "cachedResultName": "GPT-4O-MINI"
        },
        "messages": {
          "values": [
            {
              "content": "={{ $json.dynamic_prompt }}"
            },
            {
              "content": "=–ü—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä—É–π —ç—Ç–∏ –ø–æ—Å—Ç—ã:\\n\\n{{ JSON.stringify($json.posts_for_ai) }}"
            }
          ]
        },
        "jsonOutput": true,
        "options": {
          "maxTokens": 2000,
          "temperature": 0.3
        }
      },
      "name": "OpenAI API",
      "type": "@n8n/n8n-nodes-langchain.openAi",
      "typeVersion": 1,
      "position": [
        1000,
        0
      ],
      "id": "5ac7650f-b400-4f89-a1d6-4301823b7270",
      "credentials": {
        "openAiApi": {
          "id": "RinkWxXeXs9tiXAB",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "functionCode": "// –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –æ—Ç OpenAI —Å FIXED AI prompts v7.1\nconsole.log('ü§ñ Processing OpenAI response with FIXED prompts v7.1...');\n\ntry {\n    // –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –æ—Ç –ø—Ä–µ–¥—ã–¥—É—â–∏—Ö —É–∑–ª–æ–≤\n    const prepareForAIData = $('Prepare for AI').all()[0]?.json;\n    if (!prepareForAIData) {\n        throw new Error('Could not find data from Prepare for AI node');\n    }\n    \n    const groupedPosts = prepareForAIData.grouped_posts || {};\n    const channelCategoryMap = prepareForAIData.channel_category_map || {};\n    const originalStats = prepareForAIData.stats || {};\n    const originalTimestamp = prepareForAIData.timestamp || '';\n    \n    console.log('‚úÖ Found data from Prepare for AI node (FIXED v7.1)');\n    console.log('üìä Channel-Category mapping:', Object.keys(channelCategoryMap));\n    console.log('üîß AI prompts fixed:', prepareForAIData.fixed_ai_prompts);\n    \n    // –ò–∑–≤–ª–µ–∫–∞–µ–º AI –æ—Ç–≤–µ—Ç (—É–ª—É—á—à–µ–Ω–Ω–æ–µ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –∏ –ø–∞—Ä—Å–∏–Ω–≥)\n    let aiAnalysis = [];\n    \n    console.log('üîç RAW OpenAI response structure:', JSON.stringify($json, null, 2));\n    \n    if ($json.message?.content?.results) {\n        aiAnalysis = $json.message.content.results;\n        console.log('‚úÖ Found AI response in $json.message.content.results (direct format)', aiAnalysis.length, 'items');\n    } else if ($json[0]?.message?.content?.results) {\n        aiAnalysis = $json[0].message.content.results;\n        console.log('‚úÖ Found AI response in $json[0].message.content.results (array format)', aiAnalysis.length, 'items');\n    } else if ($json[0]?.message?.content?.posts) {\n        aiAnalysis = $json[0].message.content.posts;\n        console.log('‚úÖ Found AI response in $json[0].message.content.posts (array format)', aiAnalysis.length, 'items');\n    } else if ($json[0]?.message?.content && typeof $json[0].message.content === 'object') {\n        // –í–æ–∑–º–æ–∂–Ω–æ content —ç—Ç–æ –æ–±—ä–µ–∫—Ç –Ω–∞–ø—Ä—è–º—É—é, –∞ –Ω–µ —Å—Ç—Ä–æ–∫–∞\n        if ($json[0].message.content.results) {\n            aiAnalysis = $json[0].message.content.results;\n            console.log('‚úÖ Found AI response in $json[0].message.content.results (direct object)', aiAnalysis.length, 'items');\n        } else {\n            console.log('‚ö†Ô∏è Content is object but no results field found');\n        }\n    } else if ($json.message?.content && typeof $json.message.content === 'string') {\n        try {\n            const parsed = JSON.parse($json.message.content);\n            aiAnalysis = parsed.results || parsed;\n            console.log('‚úÖ Found AI response in message.content (string format)', aiAnalysis.length, 'items');\n        } catch (error) {\n            console.log('‚ö†Ô∏è Failed to parse message.content as JSON:', error.message);\n        }\n    } else if (Array.isArray($json)) {\n        aiAnalysis = $json;\n        console.log('‚úÖ Found AI response as direct array', aiAnalysis.length, 'items');\n    } else {\n        console.log('‚ùå Could not find AI response in expected fields');\n        console.log('üîç Available $json structure keys:', Object.keys($json));\n        if ($json[0]) {\n            console.log('üîç $json[0] structure keys:', Object.keys($json[0]));\n            if ($json[0].message) {\n                console.log('üîç $json[0].message structure keys:', Object.keys($json[0].message));\n            }\n        }\n    }\n    \n    console.log(`üìù AI Analysis extracted: ${aiAnalysis.length} items`);\n    \n    // –ü—Ä–∏–º–µ–Ω—è–µ–º AI –∞–Ω–∞–ª–∏–∑ –∫ –ø–æ—Å—Ç–∞–º —Å Binary Relevance –ø–æ–¥—Ö–æ–¥–æ–º\n    const processedChannels = {};\n    \n    Object.keys(groupedPosts).forEach(channelKey => {\n        const channelData = groupedPosts[channelKey];\n        const channelCategories = channelCategoryMap[channelData.channel_username] || [];\n        \n        console.log(`üîÑ Processing channel: ${channelData.channel_title}`);\n        console.log(`  üè∑Ô∏è Channel categories: ${channelCategories.map(c => c.name).join(', ')}`);\n        \n        const processedPosts = channelData.posts.map(post => {\n            // –ò—â–µ–º AI –∞–Ω–∞–ª–∏–∑ –¥–ª—è —ç—Ç–æ–≥–æ –ø–æ—Å—Ç–∞\n            const analysis = aiAnalysis.find(item => \n                item.id == post.id || \n                (item.text && post.text && item.text.includes(post.text.substring(0, 50)))\n            );\n            \n            // Binary Relevance v6.0: –ø—Ä–æ—Å—Ç–æ –ø—Ä–æ–≤–µ—Ä—è–µ–º summary !== \"NULL\"\n            const isRelevant = analysis && analysis.summary && analysis.summary !== 'NULL';\n            \n            const result = {\n                ...post,\n                ai_summary: analysis?.summary || post.text?.substring(0, 150) + '...',\n                ai_importance: analysis?.importance || 0,\n                ai_urgency: analysis?.urgency || 0,\n                ai_significance: analysis?.significance || 0,\n                processed_by_ai: !!analysis,\n                channel_categories: channelCategories.map(c => c.name),\n                // Binary Relevance: —Ä–µ–ª–µ–≤–∞–Ω—Ç–µ–Ω –µ—Å–ª–∏ summary –Ω–µ NULL\n                is_relevant: isRelevant,\n                parsing_method: 'binary_relevance_v7.1_fixed'\n            };\n            \n            console.log(`  üìù Post ${post.id}: relevant=${isRelevant}, importance=${result.ai_importance}, urgency=${result.ai_urgency}, significance=${result.ai_significance}`);\n            return result;\n        });\n        \n        // –§–∏–ª—å—Ç—Ä—É–µ–º —Ç–æ–ª—å–∫–æ –ø–æ —Ä–µ–ª–µ–≤–∞–Ω—Ç–Ω–æ—Å—Ç–∏ (summary !== NULL)\n        const relevantPosts = processedPosts.filter(post => {\n            if (!post.is_relevant) {\n                console.log(`  ‚ö†Ô∏è –ü–æ—Å—Ç ${post.id} –æ—Ç—Ñ–∏–ª—å—Ç—Ä–æ–≤–∞–Ω: –Ω–µ —Ä–µ–ª–µ–≤–∞–Ω—Ç–µ–Ω (summary=NULL)`);\n                return false;\n            }\n            return true;\n        });\n        \n        // –£–º–Ω–∞—è —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –ø–æ –º–µ—Ç—Ä–∏–∫–∞–º + views\n        relevantPosts.sort((a, b) => {\n            const scoreA = a.ai_importance * 3 + a.ai_urgency * 2 + a.ai_significance * 2 + Math.log(a.views || 1);\n            const scoreB = b.ai_importance * 3 + b.ai_urgency * 2 + b.ai_significance * 2 + Math.log(b.views || 1);\n            return scoreB - scoreA;\n        });\n        \n        processedChannels[channelKey] = {\n            ...channelData,\n            posts: relevantPosts.slice(0, 8), // –¢–æ–ø 8\n            all_processed_posts: processedPosts.length,\n            relevant_posts: relevantPosts.length,\n            ai_processed: true,\n            channel_categories: channelCategories.map(c => c.name)\n        };\n        \n        console.log(`üìä ${channelData.channel_title}: ${processedPosts.length} total ‚Üí ${relevantPosts.length} relevant ‚Üí ${Math.min(8, relevantPosts.length)} final`);\n    });\n    \n    const result = {\n        timestamp: originalTimestamp || new Date().toISOString(),\n        processed_at: new Date().toISOString(),\n        stats: originalStats,\n        processed_channels: processedChannels,\n        total_channels: Object.keys(processedChannels).length,\n        ai_analysis_stats: {\n            total_analyzed: aiAnalysis.length,\n            avg_importance: aiAnalysis.reduce((sum, item) => sum + (item.importance || 0), 0) / Math.max(aiAnalysis.length, 1),\n            avg_urgency: aiAnalysis.reduce((sum, item) => sum + (item.urgency || 0), 0) / Math.max(aiAnalysis.length, 1),\n            avg_significance: aiAnalysis.reduce((sum, item) => sum + (item.significance || 0), 0) / Math.max(aiAnalysis.length, 1),\n            relevant_posts: Object.values(processedChannels).reduce((sum, ch) => sum + ch.relevant_posts, 0)\n        },\n        many_to_many_applied: true,\n        relevance_parsing_version: 'v7.1_binary_relevance_fixed_prompts',\n        ai_prompts_fixed: true\n    };\n    \n    console.log('üîç FINAL RESULT with FIXED AI prompts v7.1:', JSON.stringify(result, null, 2));\n    return result;\n    \n} catch (error) {\n    console.log('‚ùå Error in Process AI Results:', error.message);\n    return {\n        error: 'Failed to process AI results: ' + error.message,\n        timestamp: new Date().toISOString(),\n        processed_channels: {},\n        total_channels: 0\n    };\n}"
      },
      "name": "Process AI Results",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        1300,
        0
      ],
      "id": "0ee7cbce-ceb7-4478-bace-afa8371d297e"
    },
    {
      "parameters": {
        "functionCode": "// –§–∏–Ω–∞–ª—å–Ω–∞—è –ø–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –¥–∞–π–¥–∂–µ—Å—Ç–∞ —Å FIXED AI prompts v7.1\nconst processedChannels = $json.processed_channels || {};\n\nconsole.log('üìÑ Preparing final digest with FIXED AI prompts v7.1...');\n\nconst digest = {\n  id: `digest_${Date.now()}`,\n  created_at: $json.timestamp,\n  processed_at: $json.processed_at,\n  channels: [],\n  total_posts: 0,\n  binary_relevance_applied: true,\n  with_metrics: true,\n  ai_prompts_fixed: true,\n  version: 'v7.1_fixed',\n  summary: {\n    channels_processed: Object.keys(processedChannels).length,\n    original_posts: $json.stats?.total_posts || 0,\n    relevant_posts: $json.ai_analysis_stats?.relevant_posts || 0,\n    avg_importance: $json.ai_analysis_stats?.avg_importance || 0,\n    avg_urgency: $json.ai_analysis_stats?.avg_urgency || 0,\n    avg_significance: $json.ai_analysis_stats?.avg_significance || 0\n  }\n};\n\nObject.keys(processedChannels).forEach(channelKey => {\n  const channelData = processedChannels[channelKey];\n  \n  digest.channels.push({\n    title: channelData.channel_title,\n    username: channelData.channel_username,\n    categories: channelData.channel_categories || [],\n    posts_count: channelData.posts.length,\n    relevant_posts: channelData.relevant_posts || 0,\n    posts: channelData.posts.map(post => ({\n      title: (post.text || '').substring(0, 100) + '...',\n      url: post.url,\n      views: post.views,\n      date: post.date,\n      ai_importance: post.ai_importance,\n      ai_urgency: post.ai_urgency,\n      ai_significance: post.ai_significance,\n      summary: post.ai_summary\n    }))\n  });\n  \n  digest.total_posts += channelData.posts.length;\n});\n\nconsole.log(`‚úÖ Digest ready with FIXED AI prompts v7.1: ${digest.total_posts} posts from ${digest.channels.length} channels`);\nconsole.log(`üìä Relevant posts: ${digest.summary.relevant_posts}`);\nconsole.log(`üìà Avg metrics - Importance: ${digest.summary.avg_importance.toFixed(1)}, Urgency: ${digest.summary.avg_urgency.toFixed(1)}, Significance: ${digest.summary.avg_significance.toFixed(1)}`);\n\nreturn digest;"
      },
      "name": "Prepare Digest",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        1480,
        0
      ],
      "id": "8763312d-2d01-48b8-bce1-19f9bb0f47a5"
    },
    {
      "parameters": {
        "functionCode": "// –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –¥–∞–π–¥–∂–µ—Å—Ç–∞ –≤ Backend API —Å FIXED AI prompts v7.1\nconst digest = $json;\n\nconsole.log('üíæ Saving FIXED digest v7.1 to Backend API...');\nconsole.log('Digest ID:', digest.id);\nconsole.log('Total posts:', digest.total_posts);\nconsole.log('Channels:', digest.channels.length);\nconsole.log('AI prompts fixed:', digest.ai_prompts_fixed);\nconsole.log('Version:', digest.version);\nconsole.log('Relevant posts:', digest.summary.relevant_posts);\n\n// –ü–æ–¥–≥–æ—Ç–∞–≤–ª–∏–≤–∞–µ–º –¥–∞–Ω–Ω—ã–µ –¥–ª—è Backend API\nconst backendPayload = {\n  digest_id: digest.id,\n  total_posts: digest.total_posts,\n  channels_processed: digest.summary.channels_processed,\n  original_posts: digest.summary.original_posts,\n  relevant_posts: digest.summary.relevant_posts,\n  avg_importance: digest.summary.avg_importance,\n  avg_urgency: digest.summary.avg_urgency,\n  avg_significance: digest.summary.avg_significance,\n  binary_relevance_applied: digest.binary_relevance_applied,\n  with_metrics: digest.with_metrics,\n  ai_prompts_fixed: digest.ai_prompts_fixed,\n  version: digest.version,\n  digest_data: JSON.stringify(digest), // –ü–æ–ª–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –¥–∞–π–¥–∂–µ—Å—Ç–∞ –∫–∞–∫ JSON —Å—Ç—Ä–æ–∫–∞\n  processed_at: digest.processed_at\n};\n\nconsole.log('üì§ Payload for Backend API (FIXED v7.1):', JSON.stringify(backendPayload, null, 2));\n\n// –í–æ–∑–≤—Ä–∞—â–∞–µ–º payload –¥–ª—è HTTP Request node\nreturn {\n  success: true,\n  digest_id: digest.id,\n  backend_payload: backendPayload,\n  message: `FIXED AI prompts v7.1 digest prepared for Backend API: ${digest.total_posts} posts, ${digest.summary.relevant_posts} relevant`,\n  timestamp: new Date().toISOString(),\n  version: 'v7.1_fixed',\n  metrics_stats: {\n    avg_importance: digest.summary.avg_importance,\n    avg_urgency: digest.summary.avg_urgency,\n    avg_significance: digest.summary.avg_significance,\n    channels_with_categories: digest.channels.filter(ch => ch.categories.length > 0).length\n  }\n};"
      },
      "name": "Prepare Backend Payload",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        1660,
        0
      ],
      "id": "c7c4b22d-5c42-4a51-aaf8-3eaed10d3633"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "http://127.0.0.1:8000/api/digests",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify($json.backend_payload) }}",
        "options": {}
      },
      "name": "Save to Backend API",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        1880,
        0
      ],
      "id": "2a636dd9-673c-4c3c-9661-d99778ea758a"
    },
    {
      "parameters": {
        "functionCode": "// –§–∏–Ω–∞–ª—å–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –≤ Backend API\nconst apiResponse = $json;\nconst preparePayloadData = $('Prepare Backend Payload').all()[0]?.json;\n\nconsole.log('‚úÖ Backend API response for FIXED v7.1:', JSON.stringify(apiResponse, null, 2));\n\nif (apiResponse.digest_id) {\n  console.log('üéâ FIXED digest v7.1 successfully saved to Backend API!');\n  console.log('üìä Digest ID:', apiResponse.digest_id);\n  console.log('üìà Total posts:', apiResponse.total_posts);\n  console.log('üìä Relevant posts:', apiResponse.relevant_posts);\n  \n  return {\n    success: true,\n    digest_id: apiResponse.digest_id,\n    backend_id: apiResponse.id,\n    message: `FIXED AI prompts v7.1 digest saved to Backend API successfully!`,\n    timestamp: new Date().toISOString(),\n    version: 'v7.1_fixed',\n    api_response: apiResponse,\n    metrics_stats: preparePayloadData?.metrics_stats || {}\n  };\n} else {\n  console.log('‚ùå Failed to save FIXED digest v7.1 to Backend API');\n  \n  return {\n    success: false,\n    error: 'Failed to save FIXED digest to Backend API',\n    api_response: apiResponse,\n    timestamp: new Date().toISOString()\n  };\n}"
      },
      "name": "Process API Response",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        2100,
        0
      ],
      "id": "1b475303-0327-4391-8a0a-c8fe5ced54a4"
    },
    {
      "parameters": {
        "functionCode": "// –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–ª—É—á–∞—è –∫–æ–≥–¥–∞ –Ω–µ—Ç –ø–æ—Å—Ç–æ–≤\nconsole.log('‚ö†Ô∏è No posts received from userbot');\n\nreturn {\n  success: false,\n  message: 'No posts to process',\n  timestamp: new Date().toISOString()\n};"
      },
      "name": "No Posts Handler",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        320,
        300
      ],
      "id": "a839444e-eec7-4c72-9c48-7b54f01fe312"
    }
  ],
  "pinData": {},
  "connections": {
    "Webhook - Receive Posts": {
      "main": [
        [
          {
            "node": "Process & Log Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process & Log Data": {
      "main": [
        [
          {
            "node": "Has Posts?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Has Posts?": {
      "main": [
        [
          {
            "node": "Group by Channels",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "No Posts Handler",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Group by Channels": {
      "main": [
        [
          {
            "node": "Prepare for AI",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare for AI": {
      "main": [
        [
          {
            "node": "OpenAI API",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI API": {
      "main": [
        [
          {
            "node": "Process AI Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process AI Results": {
      "main": [
        [
          {
            "node": "Prepare Digest",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Digest": {
      "main": [
        [
          {
            "node": "Prepare Backend Payload",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Backend Payload": {
      "main": [
        [
          {
            "node": "Save to Backend API",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Save to Backend API": {
      "main": [
        [
          {
            "node": "Process API Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": true,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "6795b34f-98b2-4c58-b002-cba5381fda7f",
  "meta": {
    "instanceId": "883bf09e5b1ec169d367de4fbfec1bb4c59c9cdd2c1af7d7b7c29577e28e6ee0"
  },
  "id": "4woIUKcHh6bley18",
  "tags": []
} 