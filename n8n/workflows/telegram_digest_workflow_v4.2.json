{
  "name": "Telegram Digest Workflow v4.3 - Fixed Webhook Body Data",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "telegram-posts",
        "options": {}
      },
      "name": "Webhook - Receive Posts",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [
        240,
        300
      ],
      "webhookId": "abc123",
      "id": "webhook-node"
    },
    {
      "parameters": {
        "functionCode": "// –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –∏ –ø—Ä–æ–≤–µ—Ä–∫–∞ –≤—Ö–æ–¥—è—â–∏—Ö –¥–∞–Ω–Ω—ã—Ö\nconst rawData = $json;\nconst data = rawData.body || rawData; // –ò–∑–≤–ª–µ–∫–∞–µ–º –¥–∞–Ω–Ω—ã–µ –∏–∑ body –µ—Å–ª–∏ –µ—Å—Ç—å\n\nconsole.log('üì• Received data from userbot:');\nconsole.log('üîç Raw data keys:', Object.keys(rawData));\nconsole.log('üîç Using data from:', rawData.body ? 'body' : 'root');\nconsole.log('  Timestamp:', data.timestamp);\nconsole.log('  Stats:', JSON.stringify(data.collection_stats, null, 2));\nconsole.log('  Posts exists:', !!data.posts);\nconsole.log('  Posts type:', typeof data.posts);\nconsole.log('  Posts count:', data.posts?.length || 0);\nconsole.log('  Channels metadata keys:', Object.keys(data.channels_metadata || {}));\n\n// –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ –µ—Å—Ç—å –ø–æ—Å—Ç—ã\nif (!data.posts || data.posts.length === 0) {\n    console.log('‚ö†Ô∏è No posts received - posts array is empty or missing');\n    console.log('   Posts value:', data.posts);\n    console.log('   Data keys:', Object.keys(data));\n    return { has_posts: false, message: 'No posts in webhook data' };\n}\n\nconsole.log(`‚úÖ Received ${data.posts.length} posts for processing`);\nreturn { ...data, has_posts: true };"
      },
      "name": "Process & Log Data",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        460,
        300
      ],
      "id": "process-log-data"
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.has_posts }}",
              "value2": true
            }
          ]
        }
      },
      "name": "Has Posts?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [
        680,
        300
      ],
      "id": "has-posts-check"
    },
    {
      "parameters": {
        "functionCode": "// –ì—Ä—É–ø–ø–∏—Ä–æ–≤–∫–∞ –ø–æ—Å—Ç–æ–≤ –ø–æ –∫–∞–Ω–∞–ª–∞–º —Å —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ–º –º–µ—Ç–∞–¥–∞–Ω–Ω—ã—Ö\nconst data = $json;\nconst posts = data.posts || [];\nconst channelsMetadata = data.channels_metadata || {};\n\nconsole.log('üìä Grouping posts by channels...');\nconsole.log('üìã Available channels metadata:', Object.keys(channelsMetadata));\n\nconst grouped = {};\n\nposts.forEach(post => {\n    const key = post.channel_username || `channel_${post.channel_id}`;\n    \n    if (!grouped[key]) {\n        grouped[key] = {\n            channel_id: post.channel_id,\n            channel_username: post.channel_username,\n            channel_title: post.channel_title,\n            posts: [],\n            categories: channelsMetadata[post.channel_username]?.categories || []\n        };\n    }\n    \n    grouped[key].posts.push(post);\n});\n\nconst result = {\n    timestamp: data.timestamp,\n    stats: data.collection_stats,\n    grouped_posts: grouped,\n    channels_metadata: channelsMetadata\n};\n\nconsole.log(`üìà Grouped into ${Object.keys(grouped).length} channels`);\nObject.keys(grouped).forEach(key => {\n    const channel = grouped[key];\n    console.log(`  üì∫ ${channel.channel_title}: ${channel.posts.length} posts, ${channel.categories.length} categories`);\n});\n\nreturn result;"
      },
      "name": "Group by Channels",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        900,
        200
      ],
      "id": "group-by-channels"
    },
    {
      "parameters": {
        "functionCode": "// –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è AI —Å –ø—Ä–∞–≤–∏–ª—å–Ω–æ–π Many-to-Many –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–æ–π v4.2\nconsole.log('ü§ñ Preparing data for OpenAI with Many-to-Many Categories v4.2...');\n\nconst groupedPostsData = $json;\nconst groupedPosts = groupedPostsData.grouped_posts || {};\nconst channelsMetadata = groupedPostsData.channels_metadata || {};\n\nconsole.log(`üìã Found grouped posts for ${Object.keys(groupedPosts).length} channels`);\nconsole.log('üìã Channels metadata available:', Object.keys(channelsMetadata));\n\n// –°–æ–±–∏—Ä–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –ø–æ Many-to-Many —Å–≤—è–∑—è–º –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –∫–∞–Ω–∞–ª–∞\nconst channelCategoryMap = {};\nconst categoryPrompts = {};\nlet allActiveCategories = new Set();\n\nObject.keys(groupedPosts).forEach(channelKey => {\n    const channelData = groupedPosts[channelKey];\n    const channelUsername = channelData.channel_username;\n    \n    console.log(`üìã –ö–∞–Ω–∞–ª: ${channelData.channel_title} (${channelUsername})`);\n    \n    // –ò—Å–ø–æ–ª—å–∑—É–µ–º –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –ø—Ä—è–º–æ –∏–∑ grouped –¥–∞–Ω–Ω—ã—Ö –∏–ª–∏ –º–µ—Ç–∞–¥–∞–Ω–Ω—ã—Ö\n    const categories = channelData.categories || channelsMetadata[channelUsername]?.categories || [];\n    const activeCategories = categories.filter(cat => cat.is_active);\n    \n    channelCategoryMap[channelUsername] = activeCategories;\n    \n    activeCategories.forEach(category => {\n        allActiveCategories.add(category.name);\n        // –°–æ—Ö—Ä–∞–Ω—è–µ–º –∏–Ω–¥–∏–≤–∏–¥—É–∞–ª—å–Ω—ã–µ AI –ø—Ä–æ–º–ø—Ç—ã –¥–ª—è –∫–∞–∂–¥–æ–π –∫–∞—Ç–µ–≥–æ—Ä–∏–∏\n        if (category.ai_prompt) {\n            categoryPrompts[category.name] = category.ai_prompt;\n        }\n        console.log(`  üè∑Ô∏è –ê–∫—Ç–∏–≤–Ω–∞—è –∫–∞—Ç–µ–≥–æ—Ä–∏—è: ${category.name}`);\n        console.log(`    üìù AI prompt: ${category.ai_prompt?.substring(0, 80)}...`);\n    });\n    \n    if (activeCategories.length === 0) {\n        console.log(`  ‚ö†Ô∏è –ù–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö –∫–∞—Ç–µ–≥–æ—Ä–∏–π –¥–ª—è ${channelUsername}`);\n    }\n});\n\n// –§–æ—Ä–º–∏—Ä—É–µ–º —Å–ø–∏—Å–æ–∫ –∫–∞—Ç–µ–≥–æ—Ä–∏–π –¥–ª—è OpenAI\nconst categories = Array.from(allActiveCategories);\n\nconsole.log(`‚úÖ Many-to-Many –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞: –ù–∞–π–¥–µ–Ω–æ ${categories.length} —É–Ω–∏–∫–∞–ª—å–Ω—ã—Ö –∞–∫—Ç–∏–≤–Ω—ã—Ö –∫–∞—Ç–µ–≥–æ—Ä–∏–π:`, categories);\nconsole.log('üîó –°–≤—è–∑–∏ –∫–∞–Ω–∞–ª–æ–≤ —Å –∫–∞—Ç–µ–≥–æ—Ä–∏—è–º–∏:');\nObject.keys(channelCategoryMap).forEach(channel => {\n    const cats = channelCategoryMap[channel].map(c => c.name).join(', ');\n    console.log(`  ${channel} ‚Üí [${cats}]`);\n});\n\n// –ü–æ–¥–≥–æ—Ç–∞–≤–ª–∏–≤–∞–µ–º –ø–æ—Å—Ç—ã –¥–ª—è AI –∞–Ω–∞–ª–∏–∑–∞\nconst postsForAI = [];\n\nObject.keys(groupedPosts).forEach(channelKey => {\n    const channelData = groupedPosts[channelKey];\n    \n    channelData.posts.forEach(post => {\n        if (post.text && post.text.length > 50) {\n            postsForAI.push({\n                id: post.id,\n                text: post.text.substring(0, 1000),\n                channel: channelData.channel_title,\n                channel_username: channelData.channel_username,\n                views: post.views || 0,\n                date: post.date,\n                url: post.url,\n                // –î–æ–±–∞–≤–ª—è–µ–º —Å–≤—è–∑–∞–Ω–Ω—ã–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –∫–∞–Ω–∞–ª–∞\n                channel_categories: channelCategoryMap[channelData.channel_username]?.map(c => c.name) || []\n            });\n        }\n    });\n});\n\nconsole.log(`üìù Prepared ${postsForAI.length} posts for AI analysis`);\n\n// –§–æ—Ä–º–∏—Ä—É–µ–º –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–π –ø—Ä–æ–º–ø—Ç —Å –∫–∞—Ç–µ–≥–æ—Ä–∏—è–º–∏ –∏–∑ —Å–≤—è–∑–∞–Ω–Ω—ã—Ö –∫–∞–Ω–∞–ª–æ–≤\nconst categoriesText = categories.map(cat => {\n    const prompt = categoryPrompts[cat] ? ` - ${categoryPrompts[cat]}` : '';\n    return `- ${cat}${prompt}`;\n}).join('\\n');\n\nconst dynamicPrompt = `–¢—ã –∞–Ω–∞–ª–∏–∑–∏—Ä—É–µ—à—å –ø–æ—Å—Ç—ã –∏–∑ Telegram –∫–∞–Ω–∞–ª–æ–≤ –∏ –æ—Ü–µ–Ω–∏–≤–∞–µ—à—å –∏—Ö —Ä–µ–ª–µ–≤–∞–Ω—Ç–Ω–æ—Å—Ç—å –ø–æ —Å–ª–µ–¥—É—é—â–∏–º –∫—Ä–∏—Ç–µ—Ä–∏—è–º:\n\n1. –ö–ê–¢–ï–ì–û–†–ò–ò (–≤—ã–±–µ—Ä–∏ 1-2 –Ω–∞–∏–±–æ–ª–µ–µ –ø–æ–¥—Ö–æ–¥—è—â–∏–µ –∏–∑ —Å–ø–∏—Å–∫–∞):\n${categoriesText}\n\n2. –ö–ê–ß–ï–°–¢–í–û (–æ—Ü–µ–Ω–∫–∞ 1-10):\n- –ò–Ω—Ñ–æ—Ä–º–∞—Ç–∏–≤–Ω–æ—Å—Ç—å –∏ —É–Ω–∏–∫–∞–ª—å–Ω–æ—Å—Ç—å\n- –ê–∫—Ç—É–∞–ª—å–Ω–æ—Å—Ç—å –∏ –≤–∞–∂–Ω–æ—Å—Ç—å  \n- –ö–∞—á–µ—Å—Ç–≤–æ –ø–æ–¥–∞—á–∏\n\n3. –ö–†–ê–¢–ö–û–ï –†–ï–ó–Æ–ú–ï (1-2 –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è)\n\n–í–æ–∑–≤—Ä–∞—â–∞–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç –≤ JSON —Ñ–æ—Ä–º–∞—Ç–µ:\n[{\"id\": \"post_id\", \"categories\": [\"–∫–∞—Ç–µ–≥–æ—Ä–∏—è1\"], \"quality_score\": 8, \"summary\": \"–∫—Ä–∞—Ç–∫–æ–µ —Ä–µ–∑—é–º–µ\"}]\n\n–û–ë–†–ê–¢–ò –í–ù–ò–ú–ê–ù–ò–ï: –ò—Å–ø–æ–ª—å–∑—É–π —Ç–æ–ª—å–∫–æ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –∏–∑ —Å–ø–∏—Å–∫–∞ –≤—ã—à–µ. –ö–∞–∂–¥—ã–π –ø–æ—Å—Ç –¥–æ–ª–∂–µ–Ω –∞–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å—Å—è –≤ –∫–æ–Ω—Ç–µ–∫—Å—Ç–µ –∫–∞–Ω–∞–ª–∞ –∏–∑ –∫–æ—Ç–æ—Ä–æ–≥–æ –æ–Ω –ø—Ä–∏—à–µ–ª.`;\n\nconsole.log('üîÆ Generated dynamic prompt with Many-to-Many categories');\nconsole.log('üìä Categories with AI prompts:', Object.keys(categoryPrompts).length);\n\n// FALLBACK —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –≤–æ–æ–±—â–µ –Ω–µ—Ç –∫–∞—Ç–µ–≥–æ—Ä–∏–π\nif (categories.length === 0) {\n    console.log('‚ùå –ö–†–ò–¢–ò–ß–ï–°–ö–ê–Ø –û–®–ò–ë–ö–ê: –ù–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö –∫–∞—Ç–µ–≥–æ—Ä–∏–π, –∏—Å–ø–æ–ª—å–∑—É–µ–º fallback');\n    const fallbackPrompt = `–ê–Ω–∞–ª–∏–∑–∏—Ä—É–π –ø–æ—Å—Ç—ã –∏ –∫–∞—Ç–µ–≥–æ—Ä–∏–∑–∏—Ä—É–π –∏—Ö –≤ –æ–±—â–∏–µ —Ç–µ–º—ã: –¢–µ—Ö–Ω–æ–ª–æ–≥–∏–∏, –ü–æ–ª–∏—Ç–∏–∫–∞, –ë–∏–∑–Ω–µ—Å, –ù–∞—É–∫–∞, –ö—É–ª—å—Ç—É—Ä–∞, –î—Ä—É–≥–æ–µ. –û—Ü–µ–Ω–∏–≤–∞–π –∫–∞—á–µ—Å—Ç–≤–æ 1-10 –∏ —Å–æ–∑–¥–∞–≤–∞–π –∫—Ä–∞—Ç–∫–æ–µ —Ä–µ–∑—é–º–µ.`;\n    \n    return {\n        timestamp: groupedPostsData.timestamp,\n        stats: groupedPostsData.stats,\n        grouped_posts: groupedPosts,\n        posts_for_ai: postsForAI,\n        total_posts_for_ai: postsForAI.length,\n        dynamic_prompt: fallbackPrompt,\n        categories: ['–û–±—â–∏–µ –Ω–æ–≤–æ—Å—Ç–∏'],\n        channel_category_map: {},\n        error: 'No active categories found'\n    };\n}\n\nreturn {\n    timestamp: groupedPostsData.timestamp,\n    stats: groupedPostsData.stats,\n    grouped_posts: groupedPosts,\n    posts_for_ai: postsForAI,\n    total_posts_for_ai: postsForAI.length,\n    dynamic_prompt: dynamicPrompt,\n    categories: categories,\n    channel_category_map: channelCategoryMap,\n    category_prompts: categoryPrompts\n};"
      },
      "name": "Prepare for AI",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        1120,
        200
      ],
      "id": "prepare-for-ai"
    },
    {
      "parameters": {
        "modelId": {
          "__rl": true,
          "value": "gpt-4o-mini",
          "mode": "list",
          "cachedResultName": "GPT-4O-MINI"
        },
        "messages": {
          "values": [
            {
              "content": "={{ $json.dynamic_prompt }}"
            },
            {
              "content": "=–ü—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä—É–π —ç—Ç–∏ –ø–æ—Å—Ç—ã:\n\n{{ JSON.stringify($json.posts_for_ai) }}"
            }
          ]
        },
        "jsonOutput": true,
        "options": {
          "maxTokens": 2000,
          "temperature": 0.3
        }
      },
      "name": "OpenAI API",
      "type": "@n8n/n8n-nodes-langchain.openAi",
      "typeVersion": 1,
      "position": [
        1340,
        200
      ],
      "id": "openai-api",
      "credentials": {
        "openAiApi": {
          "id": "RinkWxXeXs9tiXAB",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "functionCode": "// –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –æ—Ç OpenAI —Å Many-to-Many –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–æ–π v4.2\nconsole.log('ü§ñ Processing OpenAI response with Many-to-Many v4.2...');\n\ntry {\n    // –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –æ—Ç –ø—Ä–µ–¥—ã–¥—É—â–∏—Ö —É–∑–ª–æ–≤\n    const prepareForAIData = $('Prepare for AI').all()[0]?.json;\n    if (!prepareForAIData) {\n        throw new Error('Could not find data from Prepare for AI node');\n    }\n    \n    const groupedPosts = prepareForAIData.grouped_posts || {};\n    const channelCategoryMap = prepareForAIData.channel_category_map || {};\n    const originalStats = prepareForAIData.stats || {};\n    const originalTimestamp = prepareForAIData.timestamp || '';\n    \n    console.log('‚úÖ Found data from Prepare for AI node');\n    console.log('üìä Channel-Category mapping:', Object.keys(channelCategoryMap));\n    \n    // –ò–∑–≤–ª–µ–∫–∞–µ–º AI –æ—Ç–≤–µ—Ç\n    let aiAnalysis = [];\n    \n    if ($json[0]?.message?.content?.posts) {\n        aiAnalysis = $json[0].message.content.posts;\n        console.log('‚úÖ Found AI response in $json[0].message.content.posts (array format)');\n    } else if ($json.message?.content && typeof $json.message.content === 'string') {\n        try {\n            aiAnalysis = JSON.parse($json.message.content);\n            console.log('‚úÖ Found AI response in message.content (string format)');\n        } catch (error) {\n            console.log('‚ö†Ô∏è Failed to parse message.content as JSON:', error.message);\n        }\n    } else if (Array.isArray($json)) {\n        aiAnalysis = $json;\n        console.log('‚úÖ Found AI response as direct array');\n    } else {\n        console.log('‚ùå Could not find AI response in expected fields');\n        console.log('Available fields:', Object.keys($json));\n    }\n    \n    console.log(`üìù AI Analysis extracted: ${aiAnalysis.length} items`);\n    \n    // –ü—Ä–∏–º–µ–Ω—è–µ–º AI –∞–Ω–∞–ª–∏–∑ –∫ –ø–æ—Å—Ç–∞–º —Å —É—á–µ—Ç–æ–º Many-to-Many —Å–≤—è–∑–µ–π\n    const processedChannels = {};\n    \n    Object.keys(groupedPosts).forEach(channelKey => {\n        const channelData = groupedPosts[channelKey];\n        const channelCategories = channelCategoryMap[channelData.channel_username] || [];\n        \n        console.log(`üîÑ Processing channel: ${channelData.channel_title}`);\n        console.log(`  üè∑Ô∏è Channel categories: ${channelCategories.map(c => c.name).join(', ')}`);\n        \n        const processedPosts = channelData.posts.map(post => {\n            // –ò—â–µ–º AI –∞–Ω–∞–ª–∏–∑ –¥–ª—è —ç—Ç–æ–≥–æ –ø–æ—Å—Ç–∞\n            const analysis = aiAnalysis.find(item => \n                item.id == post.id || \n                (item.text && post.text && item.text.includes(post.text.substring(0, 50)))\n            );\n            \n            const result = {\n                ...post,\n                ai_categories: analysis?.categories || ['–î—Ä—É–≥–æ–µ'],\n                ai_quality_score: analysis?.quality_score || 5,\n                ai_summary: analysis?.summary || post.text?.substring(0, 150) + '...',\n                processed_by_ai: !!analysis,\n                channel_categories: channelCategories.map(c => c.name), // –î–æ–±–∞–≤–ª—è–µ–º —Å–≤—è–∑–∞–Ω–Ω—ã–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –∫–∞–Ω–∞–ª–∞\n                // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ AI –∫–∞—Ç–µ–≥–æ—Ä–∏–π –∏ –∫–∞—Ç–µ–≥–æ—Ä–∏–π –∫–∞–Ω–∞–ª–∞\n                category_match: analysis?.categories?.some(aiCat => \n                    channelCategories.some(chanCat => chanCat.name === aiCat)\n                ) || false\n            };\n            \n            console.log(`  üìù Post ${post.id}: quality=${result.ai_quality_score}, AI cats=${JSON.stringify(result.ai_categories)}, match=${result.category_match}`);\n            return result;\n        });\n        \n        // –§–∏–ª—å—Ç—Ä—É–µ–º –ø–æ –∫–∞—á–µ—Å—Ç–≤—É (‚â•6) –ò —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏—é –∫–∞—Ç–µ–≥–æ—Ä–∏—è–º –∫–∞–Ω–∞–ª–∞\n        const highQualityPosts = processedPosts.filter(post => {\n            const qualityFilter = post.ai_quality_score >= 6;\n            const categoryFilter = post.category_match || channelCategories.length === 0; // –ï—Å–ª–∏ –Ω–µ—Ç –∫–∞—Ç–µ–≥–æ—Ä–∏–π –∫–∞–Ω–∞–ª–∞, –ø—Ä–æ–ø—É—Å–∫–∞–µ–º —Ñ–∏–ª—å—Ç—Ä\n            return qualityFilter && categoryFilter;\n        });\n        \n        // –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ –∫–∞—á–µ—Å—Ç–≤—É –∏ –ø—Ä–æ—Å–º–æ—Ç—Ä–∞–º\n        highQualityPosts.sort((a, b) => {\n            const scoreA = a.ai_quality_score * 10 + Math.log(a.views || 1);\n            const scoreB = b.ai_quality_score * 10 + Math.log(b.views || 1);\n            return scoreB - scoreA;\n        });\n        \n        processedChannels[channelKey] = {\n            ...channelData,\n            posts: highQualityPosts.slice(0, 8), // –¢–æ–ø 8\n            all_processed_posts: processedPosts.length,\n            high_quality_posts: highQualityPosts.length,\n            category_matched_posts: processedPosts.filter(p => p.category_match).length,\n            ai_processed: true,\n            channel_categories: channelCategories.map(c => c.name)\n        };\n        \n        console.log(`üìä ${channelData.channel_title}: ${processedPosts.length} total ‚Üí ${highQualityPosts.length} high quality ‚Üí ${Math.min(8, highQualityPosts.length)} final`);\n    });\n    \n    const result = {\n        timestamp: originalTimestamp || new Date().toISOString(),\n        processed_at: new Date().toISOString(),\n        stats: originalStats,\n        processed_channels: processedChannels,\n        total_channels: Object.keys(processedChannels).length,\n        ai_analysis_stats: {\n            total_analyzed: aiAnalysis.length,\n            avg_quality: aiAnalysis.reduce((sum, item) => sum + (item.quality_score || 0), 0) / Math.max(aiAnalysis.length, 1),\n            category_matches: Object.values(processedChannels).reduce((sum, ch) => sum + ch.category_matched_posts, 0)\n        },\n        many_to_many_applied: true\n    };\n    \n    console.log('üîç FINAL RESULT with Many-to-Many:', JSON.stringify(result, null, 2));\n    return result;\n    \n} catch (error) {\n    console.log('‚ùå Error in Process AI Results:', error.message);\n    return {\n        error: 'Failed to process AI results: ' + error.message,\n        timestamp: new Date().toISOString(),\n        processed_channels: {},\n        total_channels: 0\n    };\n}"
      },
      "name": "Process AI Results",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        1560,
        200
      ],
      "id": "process-ai-results"
    },
    {
      "parameters": {
        "functionCode": "// –§–∏–Ω–∞–ª—å–Ω–∞—è –ø–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –¥–∞–π–¥–∂–µ—Å—Ç–∞ —Å Many-to-Many –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–µ–π\nconst processedChannels = $json.processed_channels || {};\n\nconsole.log('üìÑ Preparing final digest with Many-to-Many categories...');\n\nconst digest = {\n  id: `digest_${Date.now()}`,\n  created_at: $json.timestamp,\n  processed_at: $json.processed_at,\n  channels: [],\n  total_posts: 0,\n  many_to_many_applied: $json.many_to_many_applied || false,\n  summary: {\n    channels_processed: Object.keys(processedChannels).length,\n    original_posts: $json.stats?.total_posts || 0,\n    filtered_posts: 0,\n    category_matches: $json.ai_analysis_stats?.category_matches || 0\n  }\n};\n\nObject.keys(processedChannels).forEach(channelKey => {\n  const channelData = processedChannels[channelKey];\n  \n  digest.channels.push({\n    title: channelData.channel_title,\n    username: channelData.channel_username,\n    categories: channelData.channel_categories || [],\n    posts_count: channelData.posts.length,\n    category_matched_posts: channelData.category_matched_posts || 0,\n    posts: channelData.posts.map(post => ({\n      title: (post.text || '').substring(0, 100) + '...',\n      url: post.url,\n      views: post.views,\n      date: post.date,\n      ai_categories: post.ai_categories || [],\n      ai_quality_score: post.ai_quality_score,\n      category_match: post.category_match,\n      summary: post.ai_summary\n    }))\n  });\n  \n  digest.total_posts += channelData.posts.length;\n});\n\nconsole.log(`‚úÖ Digest ready with Many-to-Many: ${digest.total_posts} posts from ${digest.channels.length} channels`);\nconsole.log(`üìä Category matches: ${digest.summary.category_matches}`);\n\nreturn digest;"
      },
      "name": "Prepare Digest",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        1780,
        200
      ],
      "id": "prepare-digest"
    },
    {
      "parameters": {
        "functionCode": "// –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –¥–∞–π–¥–∂–µ—Å—Ç–∞ —Å Many-to-Many –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–µ–π\nconst digest = $json;\n\nconsole.log('üíæ Saving digest with Many-to-Many categories...');\nconsole.log('Digest ID:', digest.id);\nconsole.log('Total posts:', digest.total_posts);\nconsole.log('Channels:', digest.channels.length);\nconsole.log('Many-to-Many applied:', digest.many_to_many_applied);\nconsole.log('Category matches:', digest.summary.category_matches);\n\n// TODO: –ó–¥–µ—Å—å –±—É–¥–µ—Ç —Ä–µ–∞–ª—å–Ω–∞—è –æ—Ç–ø—Ä–∞–≤–∫–∞ –≤ Backend API –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è\n// –° –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–µ–π –æ —Å–≤—è–∑—è—Ö –∫–∞–Ω–∞–ª–æ–≤ –∏ –∫–∞—Ç–µ–≥–æ—Ä–∏–π\n\nreturn {\n  success: true,\n  digest_id: digest.id,\n  message: `Many-to-Many digest saved: ${digest.total_posts} posts, ${digest.summary.category_matches} category matches`,\n  timestamp: new Date().toISOString(),\n  many_to_many_stats: {\n    channels_with_categories: digest.channels.filter(ch => ch.categories.length > 0).length,\n    total_category_matches: digest.summary.category_matches\n  }\n};"
      },
      "name": "Save to Backend",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        2000,
        200
      ],
      "id": "save-to-backend"
    },
    {
      "parameters": {
        "functionCode": "// –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–ª—É—á–∞—è –∫–æ–≥–¥–∞ –Ω–µ—Ç –ø–æ—Å—Ç–æ–≤\nconsole.log('‚ö†Ô∏è No posts received from userbot');\n\nreturn {\n  success: false,\n  message: 'No posts to process',\n  timestamp: new Date().toISOString()\n};"
      },
      "name": "No Posts Handler",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        680,
        500
      ],
      "id": "no-posts-handler"
    }
  ],
  "pinData": {},
  "connections": {
    "Webhook - Receive Posts": {
      "main": [
        [
          {
            "node": "Process & Log Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process & Log Data": {
      "main": [
        [
          {
            "node": "Has Posts?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Has Posts?": {
      "main": [
        [
          {
            "node": "Group by Channels",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "No Posts Handler",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Group by Channels": {
      "main": [
        [
          {
            "node": "Prepare for AI",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare for AI": {
      "main": [
        [
          {
            "node": "OpenAI API",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI API": {
      "main": [
        [
          {
            "node": "Process AI Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process AI Results": {
      "main": [
        [
          {
            "node": "Prepare Digest",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Digest": {
      "main": [
        [
          {
            "node": "Save to Backend",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "createdAt": "2025-12-08T08:00:00.000Z",
  "updatedAt": "2025-12-08T08:00:00.000Z",
  "settings": {},
  "staticData": null,
  "tags": [],
  "triggerCount": 0,
  "active": false,
  "id": "telegram-digest-workflow-v4.2"
} 