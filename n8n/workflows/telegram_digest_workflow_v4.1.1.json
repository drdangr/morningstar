{
  "name": "telegram-digest-workflow",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "telegram-posts",
        "options": {}
      },
      "name": "Webhook - Receive Posts",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [
        -360,
        -20
      ],
      "id": "9172ddbb-e4c4-4a91-97f3-87a766c9761a",
      "webhookId": "a5dd4552-2519-46ab-9700-281a2251b295"
    },
    {
      "parameters": {
        "functionCode": "// –ü—Ä–∞–≤–∏–ª—å–Ω—ã–π –¥–æ—Å—Ç—É–ø –∫ –¥–∞–Ω–Ω—ã–º –∏–∑ INPUT\nconsole.log('üîß N8N WORKFLOW VERSION: v3.5 - Correct Access');\n\n// –í N8N Function node –¥–∞–Ω–Ω—ã–µ –º–æ–≥—É—Ç –±—ã—Ç—å –¥–æ—Å—Ç—É–ø–Ω—ã –ø–æ-—Ä–∞–∑–Ω–æ–º—É\nlet body, posts, stats;\n\n// –ü—Ä–æ–±—É–µ–º —á–µ—Ä–µ–∑ $json (—á–∞—Å—Ç–æ —Ä–∞–±–æ—Ç–∞–µ—Ç –≤ N8N)\nif ($json && $json.body) {\n    console.log('‚úÖ Found via $json.body');\n    body = $json.body;\n} \n// –ü—Ä–æ–±—É–µ–º —á–µ—Ä–µ–∑ $input.first()\nelse if ($input.first() && $input.first().body) {\n    console.log('‚úÖ Found via $input.first().body');\n    body = $input.first().body;\n}\n// –ü—Ä–æ–±—É–µ–º —á–µ—Ä–µ–∑ –ø—Ä—è–º–æ–π –¥–æ—Å—Ç—É–ø –∫ $json\nelse if ($json && $json.posts) {\n    console.log('‚úÖ Found directly in $json');\n    body = $json;\n}\nelse {\n    console.log('‚ùå Trying manual access...');\n    // –ï—Å–ª–∏ –Ω–∏—á–µ–≥–æ –Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç, –ø–æ–ø—Ä–æ–±—É–µ–º \"—Å—ã—Ä–æ–π\" –¥–æ—Å—Ç—É–ø\n    const inputData = $input.all()[0];\n    console.log('Raw input keys:', Object.keys(inputData || {}));\n    body = inputData?.body || inputData;\n}\n\nposts = body?.posts || [];\nstats = body?.collection_stats || {};\n\nconsole.log(`üìä Found: ${posts.length} posts`);\n\nreturn {\n    timestamp: body?.timestamp || new Date().toISOString(),\n    stats: stats,\n    posts: posts,\n    total_posts: posts.length,\n    success: true\n};"
      },
      "name": "Process & Log Data",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        -140,
        -20
      ],
      "id": "1b0825f9-9256-46b0-b964-886898868cee"
    },
    {
      "parameters": {
        "conditions": {
          "number": [
            {
              "value1": "={{$json.total_posts}}",
              "operation": "larger"
            }
          ]
        }
      },
      "name": "Has Posts?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [
        80,
        -20
      ],
      "id": "4de57664-8fc2-45cc-b136-e412beecc927"
    },
    {
      "parameters": {
        "functionCode": "// –ì—Ä—É–ø–ø–∏—Ä–æ–≤–∫–∞ –ø–æ—Å—Ç–æ–≤ –ø–æ –∫–∞–Ω–∞–ª–∞–º\nconst posts = $json.posts || [];\n\nconst groupedByChannel = {};\n\nposts.forEach(post => {\n  const channelKey = post.channel_username || post.channel_id;\n  \n  if (!groupedByChannel[channelKey]) {\n    groupedByChannel[channelKey] = {\n      channel_title: post.channel_title,\n      channel_username: post.channel_username,\n      posts: []\n    };\n  }\n  \n  groupedByChannel[channelKey].posts.push({\n    id: post.id,\n    text: post.text,\n    date: post.date,\n    url: post.url,\n    views: post.views,\n    media_type: post.media_type\n  });\n});\n\nconsole.log('üìã Grouped posts by channels:');\nObject.keys(groupedByChannel).forEach(channel => {\n  const data = groupedByChannel[channel];\n  console.log(`  ${data.channel_title}: ${data.posts.length} posts`);\n});\n\nreturn {\n  timestamp: $json.timestamp,\n  stats: $json.stats,\n  grouped_posts: groupedByChannel,\n  total_channels: Object.keys(groupedByChannel).length\n};"
      },
      "name": "Group by Channels",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        300,
        -120
      ],
      "id": "1323bd6e-12c0-4e0f-8183-ed1e602e6623"
    },
    {
      "parameters": {
        "url": "http://127.0.0.1:8000/api/categories",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "active_only",
              "value": "true"
            }
          ]
        },
        "options": {
          "response": {
            "response": {
              "neverError": true,
              "responseFormat": "json"
            }
          }
        }
      },
      "name": "Load Categories from Backend",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        480,
        -120
      ],
      "id": "load-categories-backend"
    },
    {
      "parameters": {
                "functionCode": "// –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è AI –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Å –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–º–∏ –∫–∞—Ç–µ–≥–æ—Ä–∏—è–º–∏ - v4.0 Categories Integration\nconsole.log('ü§ñ Preparing data for OpenAI processing with Backend Categories...');\n\n// –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –æ —Å–≥—Ä—É–ø–ø–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –ø–æ—Å—Ç–∞—Ö –æ—Ç –ø—Ä–µ–¥—ã–¥—É—â–µ–≥–æ —É–∑–ª–∞\nconst groupedPostsData = $('Group by Channels').all()[0]?.json;\nif (!groupedPostsData) {\n    console.log('‚ùå Could not find grouped posts data');\n    return { error: 'No grouped posts data found' };\n}\n\nconst groupedPosts = groupedPostsData.grouped_posts || {};\nconsole.log(`üìã Found grouped posts for ${Object.keys(groupedPosts).length} channels`);\n\n// –ò–°–ü–†–ê–í–õ–ï–ù–ê –ê–†–•–ò–¢–ï–ö–¢–£–†–ê: –ò–∑–≤–ª–µ–∫–∞–µ–º –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –∏–∑ –∫–∞–Ω–∞–ª–æ–≤ (v4.1.1)\nlet categories = [];\nconst channelCategories = new Set(); // –ò—Å–ø–æ–ª—å–∑—É–µ–º Set –¥–ª—è –¥–µ–¥—É–ø–ª–∏–∫–∞—Ü–∏–∏\n\nconsole.log('üîç –ü–†–ê–í–ò–õ–¨–ù–ê–Ø –ê–†–•–ò–¢–ï–ö–¢–£–†–ê: –ò–∑–≤–ª–µ—á–µ–Ω–∏–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–π –∏–∑ –∫–∞–Ω–∞–ª–æ–≤ v4.1.1');\n\n// –ü–æ–ª—É—á–∞–µ–º –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ –∫–∞–Ω–∞–ª–æ–≤ –∏–∑ userbot\nconst webhookData = $('Webhook - Receive Posts').all()[0]?.json;\nconst channelsMetadata = webhookData?.channels_metadata || {};\n\nconsole.log('üìã –ú–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ –∫–∞–Ω–∞–ª–æ–≤ –∏–∑ userbot:', Object.keys(channelsMetadata));\n\n// –°–æ–±–∏—Ä–∞–µ–º –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –∏–∑ –º–µ—Ç–∞–¥–∞–Ω–Ω—ã—Ö –∫–∞–Ω–∞–ª–æ–≤\nObject.keys(groupedPosts).forEach(channelKey => {\n    const channelData = groupedPosts[channelKey];\n    const channelUsername = channelData.channel_username;\n    \n    console.log(`üìã –ö–∞–Ω–∞–ª: ${channelData.channel_title} (${channelUsername})`);\n    \n    // –ò—â–µ–º –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ –¥–ª—è —ç—Ç–æ–≥–æ –∫–∞–Ω–∞–ª–∞\n    const metadata = channelsMetadata[channelUsername];\n    if (metadata && metadata.categories) {\n        metadata.categories.forEach(category => {\n            if (category.is_active) {\n                const categoryText = `${category.name}${category.description ? ' (' + category.description + ')' : ''}`;\n                channelCategories.add(categoryText);\n                console.log(`  üè∑Ô∏è –ù–∞–π–¥–µ–Ω–∞ –∫–∞—Ç–µ–≥–æ—Ä–∏—è: ${categoryText}`);\n            }\n        });\n    } else {\n        console.log(`  ‚ö†Ô∏è –ú–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–π –Ω–µ –Ω–∞–π–¥–µ–Ω—ã –¥–ª—è ${channelUsername}`);\n    }\n});\n\n// –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º Set –≤ Array\ncategories = Array.from(channelCategories);\n\nconsole.log(`‚úÖ –ò–∑–≤–ª–µ—á–µ–Ω–æ ${categories.length} —É–Ω–∏–∫–∞–ª—å–Ω—ã—Ö –∫–∞—Ç–µ–≥–æ—Ä–∏–π –∏–∑ –∫–∞–Ω–∞–ª–æ–≤:`, categories);\n\n// FALLBACK: –µ—Å–ª–∏ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –∏–∑ –∫–∞–Ω–∞–ª–æ–≤ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã, –∏—Å–ø–æ–ª—å–∑—É–µ–º –≤—Å–µ –∞–∫—Ç–∏–≤–Ω—ã–µ –∏–∑ Backend\nif (categories.length === 0) {\n    console.log('‚ö†Ô∏è FALLBACK: –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –∏–∑ –∫–∞–Ω–∞–ª–æ–≤ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã, –∏—Å–ø–æ–ª—å–∑—É–µ–º –≤—Å–µ –∞–∫—Ç–∏–≤–Ω—ã–µ –∏–∑ Backend');\n    const categoriesResponse = $json; // –û—Ç–≤–µ—Ç –æ—Ç Load Categories from Backend\n    \n    if (Array.isArray(categoriesResponse)) {\n        categories = categoriesResponse\n            .filter(category => category.is_active)\n            .map(category => `${category.name}${category.description ? ' (' + category.description + ')' : ''}`);\n        console.log('‚úÖ Processed Backend categories as fallback');\n    } else {\n        console.log('‚ùå Final fallback to hardcoded categories');\n        categories = [\n            '–¢–µ—Ö–Ω–æ–ª–æ–≥–∏–∏ (tech, AI, —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∞, —Å—Ç–∞—Ä—Ç–∞–ø—ã)',\n            '–ë–∏–∑–Ω–µ—Å (—ç–∫–æ–Ω–æ–º–∏–∫–∞, —Ñ–∏–Ω–∞–Ω—Å—ã, –∏–Ω–≤–µ—Å—Ç–∏—Ü–∏–∏)', \n            '–ü–æ–ª–∏—Ç–∏–∫–∞ (–Ω–æ–≤–æ—Å—Ç–∏, –∞–Ω–∞–ª–∏—Ç–∏–∫–∞, –º–µ–∂–¥—É–Ω–∞—Ä–æ–¥–Ω—ã–µ –æ—Ç–Ω–æ—à–µ–Ω–∏—è)',\n            '–ù–∞—É–∫–∞ (–∏—Å—Å–ª–µ–¥–æ–≤–∞–Ω–∏—è, –æ—Ç–∫—Ä—ã—Ç–∏—è, –º–µ–¥–∏—Ü–∏–Ω–∞)',\n            '–†–∞–∑–≤–ª–µ—á–µ–Ω–∏—è (–∫—É–ª—å—Ç—É—Ä–∞, —Å–ø–æ—Ä—Ç, –º–µ–¥–∏–∞)',\n            '–î—Ä—É–≥–æ–µ'\n        ];\n    }\n}\n\nconsole.log(`üìù Using ${categories.length} categories from Backend:`, categories);\n\n// –ü–æ–¥–≥–æ—Ç–∞–≤–ª–∏–≤–∞–µ–º –ø–æ—Å—Ç—ã –¥–ª—è AI –∞–Ω–∞–ª–∏–∑–∞\nconst postsForAI = [];\n\nObject.keys(groupedPosts).forEach(channelKey => {\n  const channelData = groupedPosts[channelKey];\n  \n  channelData.posts.forEach(post => {\n    if (post.text && post.text.length > 50) {\n      postsForAI.push({\n        id: post.id,\n        text: post.text.substring(0, 1000), // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –¥–ª–∏–Ω—É –¥–ª—è AI\n        channel: channelData.channel_title,\n        views: post.views || 0,\n        date: post.date,\n        url: post.url\n      });\n    }\n  });\n});\n\nconsole.log(`üìù Prepared ${postsForAI.length} posts for AI analysis`);\n\n// –§–æ—Ä–º–∏—Ä—É–µ–º –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–π –ø—Ä–æ–º–ø—Ç —Å –∫–∞—Ç–µ–≥–æ—Ä–∏—è–º–∏ –∏–∑ Backend\nconst categoriesText = categories.map((cat, index) => `- ${cat}`).join('\\n');\n\nconst dynamicPrompt = `–¢—ã –∞–Ω–∞–ª–∏–∑–∏—Ä—É–µ—à—å –ø–æ—Å—Ç—ã –∏–∑ Telegram –∫–∞–Ω–∞–ª–æ–≤ –∏ –æ—Ü–µ–Ω–∏–≤–∞–µ—à—å –∏—Ö —Ä–µ–ª–µ–≤–∞–Ω—Ç–Ω–æ—Å—Ç—å –ø–æ —Å–ª–µ–¥—É—é—â–∏–º –∫—Ä–∏—Ç–µ—Ä–∏—è–º:\n\n1. –ö–ê–¢–ï–ì–û–†–ò–ò (–≤—ã–±–µ—Ä–∏ 1-2 –Ω–∞–∏–±–æ–ª–µ–µ –ø–æ–¥—Ö–æ–¥—è—â–∏–µ –∏–∑ —Å–ø–∏—Å–∫–∞):\n${categoriesText}\n\n2. –ö–ê–ß–ï–°–¢–í–û (–æ—Ü–µ–Ω–∫–∞ 1-10):\n- –ò–Ω—Ñ–æ—Ä–º–∞—Ç–∏–≤–Ω–æ—Å—Ç—å –∏ —É–Ω–∏–∫–∞–ª—å–Ω–æ—Å—Ç—å\n- –ê–∫—Ç—É–∞–ª—å–Ω–æ—Å—Ç—å –∏ –≤–∞–∂–Ω–æ—Å—Ç—å  \n- –ö–∞—á–µ—Å—Ç–≤–æ –ø–æ–¥–∞—á–∏\n\n3. –ö–†–ê–¢–ö–û–ï –†–ï–ó–Æ–ú–ï (1-2 –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è)\n\n–í–æ–∑–≤—Ä–∞—â–∞–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç –≤ JSON —Ñ–æ—Ä–º–∞—Ç–µ:\n[{\"id\": \"post_id\", \"categories\": [\"–∫–∞—Ç–µ–≥–æ—Ä–∏—è1\"], \"quality_score\": 8, \"summary\": \"–∫—Ä–∞—Ç–∫–æ–µ —Ä–µ–∑—é–º–µ\"}]`;\n\nconsole.log('üîÆ Generated dynamic prompt with Backend categories');\n\nreturn {\n  timestamp: groupedPostsData.timestamp,\n  stats: groupedPostsData.stats,\n  grouped_posts: groupedPosts,\n  posts_for_ai: postsForAI,\n  total_posts_for_ai: postsForAI.length,\n  dynamic_prompt: dynamicPrompt,\n  backend_categories: categories\n};"
      },
      "name": "Prepare for AI",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        680,
        -120
      ],
      "id": "5b8e822c-0d5b-450e-ab78-e5d26cf48007"
    },
    {
      "parameters": {
        "modelId": {
          "__rl": true,
          "value": "gpt-4o-mini",
          "mode": "list",
          "cachedResultName": "GPT-4O-MINI"
        },
        "messages": {
          "values": [
            {
              "content": "={{ $json.dynamic_prompt }}"
            },
            {
              "content": "=–ü—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä—É–π —ç—Ç–∏ –ø–æ—Å—Ç—ã:\n\n{{ JSON.stringify($json.posts_for_ai) }}"
            }
          ]
        },
        "jsonOutput": true,
        "options": {
          "maxTokens": 2000,
          "temperature": 0.3
        }
      },
      "name": "OpenAI API",
      "type": "@n8n/n8n-nodes-langchain.openAi",
      "typeVersion": 1,
      "position": [
        900,
        -120
      ],
      "id": "e891f7fa-4697-4c54-b535-07adaf5d157a",
      "credentials": {
        "openAiApi": {
          "id": "RinkWxXeXs9tiXAB",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
                "functionCode": "// –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –æ—Ç –≤—Å—Ç—Ä–æ–µ–Ω–Ω–æ–≥–æ OpenAI node - v4.1 Array Format\nconsole.log('ü§ñ Processing OpenAI response - v4.1...');\nconsole.log('üì• Raw $json:', JSON.stringify($json, null, 2));\nconsole.log('üì• Raw $input.all():', JSON.stringify($input.all(), null, 2));\n\ntry {\n    // –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –æ—Ç –ø—Ä–µ–¥—ã–¥—É—â–∏—Ö —É–∑–ª–æ–≤\n    let groupedPosts = {};\n    let originalStats = {};\n    let originalTimestamp = '';\n    \n    // –ò—â–µ–º –∏—Å—Ö–æ–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –æ—Ç —É–∑–ª–∞ \"Prepare for AI\"\n    const prepareForAIData = $('Prepare for AI').all()[0]?.json;\n    if (prepareForAIData) {\n        console.log('‚úÖ Found data from Prepare for AI node');\n        groupedPosts = prepareForAIData.grouped_posts || {};\n        originalStats = prepareForAIData.stats || {};\n        originalTimestamp = prepareForAIData.timestamp || '';\n    } else {\n        console.log('‚ùå Could not find data from Prepare for AI node');\n    }\n    \n    // –ò–∑–≤–ª–µ–∫–∞–µ–º AI –æ—Ç–≤–µ—Ç –∏–∑ –≤—Å—Ç—Ä–æ–µ–Ω–Ω–æ–≥–æ OpenAI node\n    let aiAnalysis = [];\n    \n    // –í—Å—Ç—Ä–æ–µ–Ω–Ω—ã–π OpenAI node –º–æ–∂–µ—Ç –≤–æ–∑–≤—Ä–∞—â–∞—Ç—å –¥–∞–Ω–Ω—ã–µ –≤ —Ä–∞–∑–Ω—ã—Ö —Ñ–æ—Ä–º–∞—Ç–∞—Ö\n    if ($json[0]?.message?.content?.posts) {\n        // –î–∞–Ω–Ω—ã–µ –≤ –º–∞—Å—Å–∏–≤–µ - –Ω–æ–≤—ã–π —Ñ–æ—Ä–º–∞—Ç OpenAI node v4.1\n        aiAnalysis = $json[0].message.content.posts;\n        console.log('‚úÖ Found AI response in $json[0].message.content.posts (array format v4.1)');\n    } else if ($json.message?.content?.results) {\n        // –î–∞–Ω–Ω—ã–µ —É–∂–µ –≤ –æ–±—ä–µ–∫—Ç–µ message.content.results\n        aiAnalysis = $json.message.content.results;\n        console.log('‚úÖ Found AI response in message.content.results (object format)');\n    } else if ($json.message?.content && typeof $json.message.content === 'string') {\n        // –î–∞–Ω–Ω—ã–µ –≤ —Å—Ç—Ä–æ–∫–µ message.content\n        try {\n            aiAnalysis = JSON.parse($json.message.content);\n            console.log('‚úÖ Found AI response in message.content (string format)');\n        } catch (error) {\n            console.log('‚ö†Ô∏è Failed to parse message.content as JSON:', error.message);\n        }\n    } else if ($json.text) {\n        // –î–∞–Ω–Ω—ã–µ –≤ –ø–æ–ª–µ text\n        try {\n            aiAnalysis = JSON.parse($json.text);\n            console.log('‚úÖ Found AI response in text');\n        } catch (error) {\n            console.log('‚ö†Ô∏è Failed to parse text as JSON:', error.message);\n        }\n    } else if ($json.response) {\n        // –î–∞–Ω–Ω—ã–µ –≤ –ø–æ–ª–µ response\n        try {\n            aiAnalysis = JSON.parse($json.response);\n            console.log('‚úÖ Found AI response in response');\n        } catch (error) {\n            console.log('‚ö†Ô∏è Failed to parse response as JSON:', error.message);\n        }\n    } else {\n        console.log('‚ùå Could not find AI response in expected fields');\n        console.log('Available fields:', Object.keys($json));\n    }\n    \n    console.log(`üìù AI Analysis extracted: ${aiAnalysis.length} items`);\n    if (aiAnalysis.length > 0) {\n        console.log('üìù Sample analysis:', JSON.stringify(aiAnalysis[0], null, 2));\n    }\n    \n    // –ü—Ä–∏–º–µ–Ω—è–µ–º AI –∞–Ω–∞–ª–∏–∑ –∫ –ø–æ—Å—Ç–∞–º\n    const processedChannels = {};\n    \n    Object.keys(groupedPosts).forEach(channelKey => {\n        const channelData = groupedPosts[channelKey];\n        console.log(`üîÑ Processing channel: ${channelData.channel_title} (${channelData.posts.length} posts)`);\n        \n        const processedPosts = channelData.posts.map(post => {\n            // –ò—â–µ–º AI –∞–Ω–∞–ª–∏–∑ –¥–ª—è —ç—Ç–æ–≥–æ –ø–æ—Å—Ç–∞\n            const analysis = aiAnalysis.find(item => {\n                return item.id == post.id || // –°—Ä–∞–≤–Ω–∏–≤–∞–µ–º —Å –ø—Ä–∏–≤–µ–¥–µ–Ω–∏–µ–º —Ç–∏–ø–æ–≤\n                       (item.text && post.text && item.text.includes(post.text.substring(0, 50)));\n            });\n            \n            const result = {\n                ...post,\n                ai_categories: analysis?.categories || ['–î—Ä—É–≥–æ–µ'],\n                ai_quality_score: analysis?.quality_score || 5,\n                ai_summary: analysis?.summary || post.text?.substring(0, 150) + '...',\n                processed_by_ai: !!analysis\n            };\n            \n            console.log(`  üìù Post ${post.id}: quality=${result.ai_quality_score}, categories=${JSON.stringify(result.ai_categories)}`);\n            return result;\n        });\n        \n        // –§–∏–ª—å—Ç—Ä—É–µ–º –ø–æ –∫–∞—á–µ—Å—Ç–≤—É (–æ—Å—Ç–∞–≤–ª—è–µ–º —Å –æ—Ü–µ–Ω–∫–æ–π >= 6)\n        const highQualityPosts = processedPosts.filter(post => post.ai_quality_score >= 6);\n        \n        // –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ –∫–∞—á–µ—Å—Ç–≤—É –∏ –ø—Ä–æ—Å–º–æ—Ç—Ä–∞–º\n        highQualityPosts.sort((a, b) => {\n            const scoreA = a.ai_quality_score * 10 + Math.log(a.views || 1);\n            const scoreB = b.ai_quality_score * 10 + Math.log(b.views || 1);\n            return scoreB - scoreA;\n        });\n        \n        processedChannels[channelKey] = {\n            ...channelData,\n            posts: highQualityPosts.slice(0, 8), // –¢–æ–ø 8 –∫–∞—á–µ—Å—Ç–≤–µ–Ω–Ω—ã—Ö –ø–æ—Å—Ç–æ–≤\n            all_processed_posts: processedPosts.length,\n            high_quality_posts: highQualityPosts.length,\n            ai_processed: true\n        };\n        \n        console.log(`üìä ${channelData.channel_title}: ${processedPosts.length} total ‚Üí ${highQualityPosts.length} high quality ‚Üí ${Math.min(8, highQualityPosts.length)} final`);\n    });\n    \n    const result = {\n        timestamp: originalTimestamp || new Date().toISOString(),\n        processed_at: new Date().toISOString(),\n        stats: originalStats,\n        processed_channels: processedChannels,\n        total_channels: Object.keys(processedChannels).length,\n        ai_analysis_stats: {\n            total_analyzed: aiAnalysis.length,\n            avg_quality: aiAnalysis.reduce((sum, item) => sum + (item.quality_score || 0), 0) / Math.max(aiAnalysis.length, 1)\n        }\n    };\n    \n    console.log('üîç FINAL RESULT from Process AI Results:', JSON.stringify(result, null, 2));\n    return result;\n    \n} catch (error) {\n    console.log('‚ùå Error in Process AI Results:', error.message);\n    console.log('‚ùå Error stack:', error.stack);\n    return {\n        error: 'Failed to process AI results: ' + error.message,\n        timestamp: new Date().toISOString(),\n        processed_channels: {},\n        total_channels: 0\n    };\n}"
      },
      "name": "Process AI Results",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        1120,
        -120
      ],
      "id": "38fe701d-f9b2-4934-9fb3-1a5c7393dd44"
    },
    {
      "parameters": {
        "functionCode": "// –§–∏–Ω–∞–ª—å–Ω–∞—è –ø–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –¥–∞–π–¥–∂–µ—Å—Ç–∞\nconst processedChannels = $json.processed_channels || {};\n\nconsole.log('üìÑ Preparing final digest...');\n\nconst digest = {\n  id: `digest_${Date.now()}`,\n  created_at: $json.timestamp,\n  processed_at: $json.processed_at,\n  channels: [],\n  total_posts: 0,\n  summary: {\n    channels_processed: Object.keys(processedChannels).length,\n    original_posts: $json.stats.total_posts,\n    filtered_posts: 0\n  }\n};\n\nObject.keys(processedChannels).forEach(channelKey => {\n  const channelData = processedChannels[channelKey];\n  \n  digest.channels.push({\n    title: channelData.channel_title,\n    username: channelData.channel_username,\n    posts_count: channelData.posts.length,\n    posts: channelData.posts.map(post => ({\n      title: (post.text || '').substring(0, 100) + '...',\n      url: post.url,\n      views: post.views,\n      date: post.date\n    }))\n  });\n  \n  digest.total_posts += channelData.posts.length;\n  digest.summary.filtered_posts += channelData.filtered_count;\n});\n\nconsole.log(`‚úÖ Digest ready: ${digest.total_posts} posts from ${digest.channels.length} channels`);\n\nreturn digest;"
      },
      "name": "Prepare Digest",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        1340,
        -120
      ],
      "id": "7debe243-bf64-4da4-80cd-7fef691b5306"
    },
    {
      "parameters": {
        "functionCode": "// –û—Ç–ø—Ä–∞–≤–∫–∞ –æ–±—Ä–∞—Ç–Ω–æ –≤ Backend API (–∏–ª–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ)\nconst digest = $json;\n\nconsole.log('üíæ Saving digest to backend...');\nconsole.log('Digest ID:', digest.id);\nconsole.log('Total posts:', digest.total_posts);\nconsole.log('Channels:', digest.channels.length);\n\n// TODO: –ó–¥–µ—Å—å –±—É–¥–µ—Ç —Ä–µ–∞–ª—å–Ω–∞—è –æ—Ç–ø—Ä–∞–≤–∫–∞ –≤ Backend API\n// –ü–æ–∫–∞ –ø—Ä–æ—Å—Ç–æ –ª–æ–≥–∏—Ä—É–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç\n\nreturn {\n  success: true,\n  digest_id: digest.id,\n  message: `Digest saved with ${digest.total_posts} posts from ${digest.channels.length} channels`,\n  timestamp: new Date().toISOString()\n};"
      },
      "name": "Save to Backend",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        1560,
        -120
      ],
      "id": "81705602-11d9-4b48-a8ea-9d4d7e1d8bc2"
    },
    {
      "parameters": {
        "functionCode": "// –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–ª—É—á–∞—è –∫–æ–≥–¥–∞ –Ω–µ—Ç –ø–æ—Å—Ç–æ–≤\nconsole.log('‚ö†Ô∏è No posts received from userbot');\n\nreturn {\n  success: false,\n  message: 'No posts to process',\n  timestamp: new Date().toISOString()\n};"
      },
      "name": "No Posts Handler",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        300,
        80
      ],
      "id": "4ce27e20-aee4-4d1b-ba9f-9e49481397f5"
    }
  ],
  "pinData": {},
  "connections": {
    "Webhook - Receive Posts": {
      "main": [
        [
          {
            "node": "Process & Log Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process & Log Data": {
      "main": [
        [
          {
            "node": "Has Posts?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Has Posts?": {
      "main": [
        [
          {
            "node": "Group by Channels",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "No Posts Handler",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Group by Channels": {
      "main": [
        [
          {
            "node": "Load Categories from Backend",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
          "Load Categories from Backend": {
      "main": [
        [
          {
            "node": "Prepare for AI",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare for AI": {
      "main": [
        [
          {
            "node": "OpenAI API",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI API": {
      "main": [
        [
          {
            "node": "Process AI Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process AI Results": {
      "main": [
        [
          {
            "node": "Prepare Digest",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Digest": {
      "main": [
        [
          {
            "node": "Save to Backend",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": true,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "06c694e5-56f5-4413-aa2a-9c5630226c50",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "883bf09e5b1ec169d367de4fbfec1bb4c59c9cdd2c1af7d7b7c29577e28e6ee0"
  },
  "id": "kU4Kfmpda3XDq6Tz",
  "tags": []
} 