{
  "name": "Telegram Digest Workflow",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "telegram-posts",
        "options": {}
      },
      "name": "Webhook - Receive Posts",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [
        240,
        300
      ],
      "id": "webhook-receive-posts"
    },
    {
      "parameters": {
        "functionCode": "// –£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –¥–∞–Ω–Ω—ã—Ö webhook - v3.7 Real Data Format\nconsole.log('üîß N8N WORKFLOW VERSION: v3.7 Real Data Format - 2025-12-07 Stage 3');\nconsole.log('üì• Raw input data:', JSON.stringify($input.all(), null, 2));\n\ntry {\n    let body, posts, stats;\n    \n    // –ú–µ—Ç–æ–¥ 1: Webhook data –≤ –∫–æ—Ä–Ω–µ $json (Stage 2 userbot —Ñ–æ—Ä–º–∞—Ç)\n    if ($json && ($json.posts || $json.collection_stats)) {\n        console.log('‚úÖ Method 1: Direct webhook data in $json (Stage 2 format)');\n        body = $json;\n    }\n    // –ú–µ—Ç–æ–¥ 2: –í $input.first().json –Ω–∞–ø—Ä—è–º—É—é (Stage 2 userbot —Ñ–æ—Ä–º–∞—Ç)\n    else if ($input.first() && $input.first().json && ($input.first().json.posts || $input.first().json.collection_stats)) {\n        console.log('‚úÖ Method 2: Direct in $input.first().json (Stage 2 format)');\n        body = $input.first().json;\n    }\n    // –ú–µ—Ç–æ–¥ 3: –ü—Ä—è–º–æ–π –¥–æ—Å—Ç—É–ø –∫ $json.body (—Ç–µ—Å—Ç–æ–≤—ã–π —Ñ–æ—Ä–º–∞—Ç)\n    else if ($json && $json.body) {\n        console.log('‚úÖ Method 3: Found via $json.body (test format)');\n        body = $json.body;\n    }\n    // –ú–µ—Ç–æ–¥ 4: –ß–µ—Ä–µ–∑ $input.first().json.body (—Ç–µ—Å—Ç–æ–≤—ã–π —Ñ–æ—Ä–º–∞—Ç)\n    else if ($input.first() && $input.first().json && $input.first().json.body) {\n        console.log('‚úÖ Method 4: Found via $input.first().json.body (test format)');\n        body = $input.first().json.body;\n    }\n    // –ú–µ—Ç–æ–¥ 5: Fallback - –∏—â–µ–º –≤–æ –≤—Å–µ—Ö –≤—Ö–æ–¥—è—â–∏—Ö –¥–∞–Ω–Ω—ã—Ö\n    else {\n        console.log('‚ö†Ô∏è Method 5: Using fallback search');\n        const allInputs = $input.all();\n        for (let i = 0; i < allInputs.length; i++) {\n            const item = allInputs[i];\n            // –°–Ω–∞—á–∞–ª–∞ –∏—â–µ–º –ø—Ä—è–º—ã–µ –¥–∞–Ω–Ω—ã–µ\n            if (item.json && (item.json.posts || item.json.collection_stats)) {\n                body = item.json;\n                console.log(`‚úÖ Found in input[${i}].json (direct)`);\n                break;\n            }\n            // –ü–æ—Ç–æ–º –≤ –æ–±–µ—Ä—Ç–∫–µ body\n            else if (item.json && item.json.body) {\n                body = item.json.body;\n                console.log(`‚úÖ Found in input[${i}].json.body`);\n                break;\n            }\n        }\n        \n        if (!body) {\n            console.log('‚ùå No valid data found, using empty fallback');\n            body = { posts: [], collection_stats: {} };\n        }\n    }\n    \n    stats = body.collection_stats || {};\n    posts = body.posts || [];\n    \n    console.log(`üìä Processed: ${posts.length} posts from ${stats.successful_channels || 0} channels`);\n    console.log(`üìã Stats:`, JSON.stringify(stats, null, 2));\n    console.log(`üìù First post sample:`, posts[0] ? JSON.stringify(posts[0], null, 2) : 'No posts');\n    \n    const result = {\n        timestamp: body.timestamp || new Date().toISOString(),\n        stats: stats,\n        posts: posts,\n        total_posts: posts.length,\n        success: true\n    };\n    \n    console.log('üîç FINAL RESULT:', JSON.stringify(result, null, 2));\n    return result;\n    \n} catch (error) {\n    console.log('‚ùå Error processing data:', error.message);\n    console.log('‚ùå Error stack:', error.stack);\n    return {\n        error: 'Failed to process data: ' + error.message,\n        total_posts: 0,\n        success: false,\n        timestamp: new Date().toISOString()\n    };\n}"
      },
      "name": "Process & Log Data",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        460,
        300
      ],
      "id": "process-log-data"
    },
    {
      "parameters": {
        "conditions": {
          "number": [
            {
              "value1": "={{$json.total_posts}}",
              "operation": "larger",
              "value2": 0
            }
          ]
        }
      },
      "name": "Has Posts?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [
        680,
        300
      ],
      "id": "has-posts-check"
    },
    {
      "parameters": {
        "functionCode": "// –ì—Ä—É–ø–ø–∏—Ä–æ–≤–∫–∞ –ø–æ—Å—Ç–æ–≤ –ø–æ –∫–∞–Ω–∞–ª–∞–º\nconst posts = $json.posts || [];\n\nconst groupedByChannel = {};\n\nposts.forEach(post => {\n  const channelKey = post.channel_username || post.channel_id;\n  \n  if (!groupedByChannel[channelKey]) {\n    groupedByChannel[channelKey] = {\n      channel_title: post.channel_title,\n      channel_username: post.channel_username,\n      posts: []\n    };\n  }\n  \n  groupedByChannel[channelKey].posts.push({\n    id: post.id,\n    text: post.text,\n    date: post.date,\n    url: post.url,\n    views: post.views,\n    media_type: post.media_type\n  });\n});\n\nconsole.log('üìã Grouped posts by channels:');\nObject.keys(groupedByChannel).forEach(channel => {\n  const data = groupedByChannel[channel];\n  console.log(`  ${data.channel_title}: ${data.posts.length} posts`);\n});\n\nreturn {\n  timestamp: $json.timestamp,\n  stats: $json.stats,\n  grouped_posts: groupedByChannel,\n  total_channels: Object.keys(groupedByChannel).length\n};"
      },
      "name": "Group by Channels",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        900,
        200
      ],
      "id": "group-by-channels"
    },
    {
      "parameters": {
        "functionCode": "// –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è AI –æ–±—Ä–∞–±–æ—Ç–∫–∏\nconst groupedPosts = $json.grouped_posts || {};\n\nconsole.log('ü§ñ Preparing data for OpenAI processing...');\n\n// –ü–æ–¥–≥–æ—Ç–∞–≤–ª–∏–≤–∞–µ–º –ø–æ—Å—Ç—ã –¥–ª—è AI –∞–Ω–∞–ª–∏–∑–∞\nconst postsForAI = [];\n\nObject.keys(groupedPosts).forEach(channelKey => {\n  const channelData = groupedPosts[channelKey];\n  \n  channelData.posts.forEach(post => {\n    if (post.text && post.text.length > 50) {\n      postsForAI.push({\n        id: post.id,\n        text: post.text.substring(0, 1000), // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –¥–ª–∏–Ω—É –¥–ª—è AI\n        channel: channelData.channel_title,\n        views: post.views || 0,\n        date: post.date,\n        url: post.url\n      });\n    }\n  });\n});\n\nconsole.log(`üìù Prepared ${postsForAI.length} posts for AI analysis`);\n\nreturn {\n  timestamp: $json.timestamp,\n  stats: $json.stats,\n  grouped_posts: groupedPosts,\n  posts_for_ai: postsForAI,\n  total_posts_for_ai: postsForAI.length\n};"
      },
      "name": "Prepare for AI",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        1120,
        200
      ],
      "id": "prepare-for-ai"
    },
    {
      "parameters": {
        "resource": "chat",
        "operation": "message",
        "model": "gpt-4o-mini",
        "messages": {
          "values": [
            {
              "role": "system",
              "content": "–¢—ã –∞–Ω–∞–ª–∏–∑–∏—Ä—É–µ—à—å –ø–æ—Å—Ç—ã –∏–∑ Telegram –∫–∞–Ω–∞–ª–æ–≤ –∏ –æ—Ü–µ–Ω–∏–≤–∞–µ—à—å –∏—Ö —Ä–µ–ª–µ–≤–∞–Ω—Ç–Ω–æ—Å—Ç—å –ø–æ —Å–ª–µ–¥—É—é—â–∏–º –∫—Ä–∏—Ç–µ—Ä–∏—è–º:\n\n1. –ö–ê–¢–ï–ì–û–†–ò–ò (–≤—ã–±–µ—Ä–∏ 1-2 –Ω–∞–∏–±–æ–ª–µ–µ –ø–æ–¥—Ö–æ–¥—è—â–∏–µ):\n- –¢–µ—Ö–Ω–æ–ª–æ–≥–∏–∏ (tech, AI, —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∞, —Å—Ç–∞—Ä—Ç–∞–ø—ã)\n- –ë–∏–∑–Ω–µ—Å (—ç–∫–æ–Ω–æ–º–∏–∫–∞, —Ñ–∏–Ω–∞–Ω—Å—ã, –∏–Ω–≤–µ—Å—Ç–∏—Ü–∏–∏)\n- –ü–æ–ª–∏—Ç–∏–∫–∞ (–Ω–æ–≤–æ—Å—Ç–∏, –∞–Ω–∞–ª–∏—Ç–∏–∫–∞, –º–µ–∂–¥—É–Ω–∞—Ä–æ–¥–Ω—ã–µ –æ—Ç–Ω–æ—à–µ–Ω–∏—è)\n- –ù–∞—É–∫–∞ (–∏—Å—Å–ª–µ–¥–æ–≤–∞–Ω–∏—è, –æ—Ç–∫—Ä—ã—Ç–∏—è, –º–µ–¥–∏—Ü–∏–Ω–∞)\n- –†–∞–∑–≤–ª–µ—á–µ–Ω–∏—è (–∫—É–ª—å—Ç—É—Ä–∞, —Å–ø–æ—Ä—Ç, –º–µ–¥–∏–∞)\n- –î—Ä—É–≥–æ–µ\n\n2. –ö–ê–ß–ï–°–¢–í–û (–æ—Ü–µ–Ω–∫–∞ 1-10):\n- –ò–Ω—Ñ–æ—Ä–º–∞—Ç–∏–≤–Ω–æ—Å—Ç—å –∏ —É–Ω–∏–∫–∞–ª—å–Ω–æ—Å—Ç—å\n- –ê–∫—Ç—É–∞–ª—å–Ω–æ—Å—Ç—å –∏ –≤–∞–∂–Ω–æ—Å—Ç—å\n- –ö–∞—á–µ—Å—Ç–≤–æ –ø–æ–¥–∞—á–∏\n\n3. –ö–†–ê–¢–ö–û–ï –†–ï–ó–Æ–ú–ï (1-2 –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è)\n\n–í–æ–∑–≤—Ä–∞—â–∞–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç –≤ JSON —Ñ–æ—Ä–º–∞—Ç–µ:\n[{\"id\": \"post_id\", \"categories\": [\"–∫–∞—Ç–µ–≥–æ—Ä–∏—è1\"], \"quality_score\": 8, \"summary\": \"–∫—Ä–∞—Ç–∫–æ–µ —Ä–µ–∑—é–º–µ\"}]"
            },
            {
              "role": "user", 
              "content": "=–ü—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä—É–π —ç—Ç–∏ –ø–æ—Å—Ç—ã:\n\n{{ JSON.stringify($json.posts_for_ai) }}"
            }
          ]
        },
        "options": {
          "temperature": 0.3,
          "maxTokens": 2000
        }
      },
      "name": "OpenAI Analysis",
      "type": "@n8n/n8n-nodes-langchain.openAi",
      "typeVersion": 1,
      "position": [
        1340,
        200
      ],
      "id": "openai-analysis",
      "credentials": {
        "openAiApi": {
          "id": "openai-api-credentials",
          "name": "OpenAI API"
        }
      }
    },
    {
      "parameters": {
        "functionCode": "// –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –æ—Ç –≤—Å—Ç—Ä–æ–µ–Ω–Ω–æ–≥–æ OpenAI node - v3.8 Fixed\nconsole.log('ü§ñ Processing OpenAI response - v3.8...');\nconsole.log('üì• Raw $json:', JSON.stringify($json, null, 2));\nconsole.log('üì• Raw $input.all():', JSON.stringify($input.all(), null, 2));\n\ntry {\n    // –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –æ—Ç –ø—Ä–µ–¥—ã–¥—É—â–∏—Ö —É–∑–ª–æ–≤\n    let groupedPosts = {};\n    let originalStats = {};\n    let originalTimestamp = '';\n    \n    // –ò—â–µ–º –∏—Å—Ö–æ–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –æ—Ç —É–∑–ª–∞ \"Prepare for AI\"\n    const prepareForAIData = $('Prepare for AI').all()[0]?.json;\n    if (prepareForAIData) {\n        console.log('‚úÖ Found data from Prepare for AI node');\n        groupedPosts = prepareForAIData.grouped_posts || {};\n        originalStats = prepareForAIData.stats || {};\n        originalTimestamp = prepareForAIData.timestamp || '';\n    } else {\n        console.log('‚ùå Could not find data from Prepare for AI node');\n    }\n    \n    // –ò–∑–≤–ª–µ–∫–∞–µ–º AI –æ—Ç–≤–µ—Ç –∏–∑ –≤—Å—Ç—Ä–æ–µ–Ω–Ω–æ–≥–æ OpenAI node\n    let aiAnalysis = [];\n    \n    // –í—Å—Ç—Ä–æ–µ–Ω–Ω—ã–π OpenAI node –º–æ–∂–µ—Ç –≤–æ–∑–≤—Ä–∞—â–∞—Ç—å –¥–∞–Ω–Ω—ã–µ –≤ —Ä–∞–∑–Ω—ã—Ö —Ñ–æ—Ä–º–∞—Ç–∞—Ö\n    if ($json.message?.content?.results) {\n        // –î–∞–Ω–Ω—ã–µ —É–∂–µ –≤ –æ–±—ä–µ–∫—Ç–µ message.content.results\n        aiAnalysis = $json.message.content.results;\n        console.log('‚úÖ Found AI response in message.content.results (object format)');\n    } else if ($json.message?.content && typeof $json.message.content === 'string') {\n        // –î–∞–Ω–Ω—ã–µ –≤ —Å—Ç—Ä–æ–∫–µ message.content\n        try {\n            aiAnalysis = JSON.parse($json.message.content);\n            console.log('‚úÖ Found AI response in message.content (string format)');\n        } catch (error) {\n            console.log('‚ö†Ô∏è Failed to parse message.content as JSON:', error.message);\n        }\n    } else if ($json.text) {\n        // –î–∞–Ω–Ω—ã–µ –≤ –ø–æ–ª–µ text\n        try {\n            aiAnalysis = JSON.parse($json.text);\n            console.log('‚úÖ Found AI response in text');\n        } catch (error) {\n            console.log('‚ö†Ô∏è Failed to parse text as JSON:', error.message);\n        }\n    } else if ($json.response) {\n        // –î–∞–Ω–Ω—ã–µ –≤ –ø–æ–ª–µ response\n        try {\n            aiAnalysis = JSON.parse($json.response);\n            console.log('‚úÖ Found AI response in response');\n        } catch (error) {\n            console.log('‚ö†Ô∏è Failed to parse response as JSON:', error.message);\n        }\n    } else {\n        console.log('‚ùå Could not find AI response in expected fields');\n        console.log('Available fields:', Object.keys($json));\n    }\n    \n    console.log(`üìù AI Analysis extracted: ${aiAnalysis.length} items`);\n    if (aiAnalysis.length > 0) {\n        console.log('üìù Sample analysis:', JSON.stringify(aiAnalysis[0], null, 2));\n    }\n    \n    // –ü—Ä–∏–º–µ–Ω—è–µ–º AI –∞–Ω–∞–ª–∏–∑ –∫ –ø–æ—Å—Ç–∞–º\n    const processedChannels = {};\n    \n    Object.keys(groupedPosts).forEach(channelKey => {\n        const channelData = groupedPosts[channelKey];\n        console.log(`üîÑ Processing channel: ${channelData.channel_title} (${channelData.posts.length} posts)`);\n        \n        const processedPosts = channelData.posts.map(post => {\n            // –ò—â–µ–º AI –∞–Ω–∞–ª–∏–∑ –¥–ª—è —ç—Ç–æ–≥–æ –ø–æ—Å—Ç–∞\n            const analysis = aiAnalysis.find(item => {\n                return item.id == post.id || // –°—Ä–∞–≤–Ω–∏–≤–∞–µ–º —Å –ø—Ä–∏–≤–µ–¥–µ–Ω–∏–µ–º —Ç–∏–ø–æ–≤\n                       (item.text && post.text && item.text.includes(post.text.substring(0, 50)));\n            });\n            \n            const result = {\n                ...post,\n                ai_categories: analysis?.categories || ['–î—Ä—É–≥–æ–µ'],\n                ai_quality_score: analysis?.quality_score || 5,\n                ai_summary: analysis?.summary || post.text?.substring(0, 150) + '...',\n                processed_by_ai: !!analysis\n            };\n            \n            console.log(`  üìù Post ${post.id}: quality=${result.ai_quality_score}, categories=${JSON.stringify(result.ai_categories)}`);\n            return result;\n        });\n        \n        // –§–∏–ª—å—Ç—Ä—É–µ–º –ø–æ –∫–∞—á–µ—Å—Ç–≤—É (–æ—Å—Ç–∞–≤–ª—è–µ–º —Å –æ—Ü–µ–Ω–∫–æ–π >= 6)\n        const highQualityPosts = processedPosts.filter(post => post.ai_quality_score >= 6);\n        \n        // –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ –∫–∞—á–µ—Å—Ç–≤—É –∏ –ø—Ä–æ—Å–º–æ—Ç—Ä–∞–º\n        highQualityPosts.sort((a, b) => {\n            const scoreA = a.ai_quality_score * 10 + Math.log(a.views || 1);\n            const scoreB = b.ai_quality_score * 10 + Math.log(b.views || 1);\n            return scoreB - scoreA;\n        });\n        \n        processedChannels[channelKey] = {\n            ...channelData,\n            posts: highQualityPosts.slice(0, 8), // –¢–æ–ø 8 –∫–∞—á–µ—Å—Ç–≤–µ–Ω–Ω—ã—Ö –ø–æ—Å—Ç–æ–≤\n            all_processed_posts: processedPosts.length,\n            high_quality_posts: highQualityPosts.length,\n            ai_processed: true\n        };\n        \n        console.log(`üìä ${channelData.channel_title}: ${processedPosts.length} total ‚Üí ${highQualityPosts.length} high quality ‚Üí ${Math.min(8, highQualityPosts.length)} final`);\n    });\n    \n    const result = {\n        timestamp: originalTimestamp || new Date().toISOString(),\n        processed_at: new Date().toISOString(),\n        stats: originalStats,\n        processed_channels: processedChannels,\n        total_channels: Object.keys(processedChannels).length,\n        ai_analysis_stats: {\n            total_analyzed: aiAnalysis.length,\n            avg_quality: aiAnalysis.reduce((sum, item) => sum + (item.quality_score || 0), 0) / Math.max(aiAnalysis.length, 1)\n        }\n    };\n    \n    console.log('üîç FINAL RESULT from Process AI Results:', JSON.stringify(result, null, 2));\n    return result;\n    \n} catch (error) {\n    console.log('‚ùå Error in Process AI Results:', error.message);\n    console.log('‚ùå Error stack:', error.stack);\n    return {\n        error: 'Failed to process AI results: ' + error.message,\n        timestamp: new Date().toISOString(),\n        processed_channels: {},\n        total_channels: 0\n    };\n}"
      },
      "name": "Process AI Results",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        1560,
        200
      ],
      "id": "process-ai-results"
    },
    {
      "parameters": {
        "functionCode": "// –§–∏–Ω–∞–ª—å–Ω–∞—è –ø–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –¥–∞–π–¥–∂–µ—Å—Ç–∞\nconst processedChannels = $json.processed_channels || {};\n\nconsole.log('üìÑ Preparing final digest...');\n\nconst digest = {\n  id: `digest_${Date.now()}`,\n  created_at: $json.timestamp,\n  processed_at: $json.processed_at,\n  channels: [],\n  total_posts: 0,\n  summary: {\n    channels_processed: Object.keys(processedChannels).length,\n    original_posts: $json.stats.total_posts,\n    filtered_posts: 0\n  }\n};\n\nObject.keys(processedChannels).forEach(channelKey => {\n  const channelData = processedChannels[channelKey];\n  \n  digest.channels.push({\n    title: channelData.channel_title,\n    username: channelData.channel_username,\n    posts_count: channelData.posts.length,\n    posts: channelData.posts.map(post => ({\n      title: (post.text || '').substring(0, 100) + '...',\n      url: post.url,\n      views: post.views,\n      date: post.date\n    }))\n  });\n  \n  digest.total_posts += channelData.posts.length;\n  digest.summary.filtered_posts += channelData.filtered_count;\n});\n\nconsole.log(`‚úÖ Digest ready: ${digest.total_posts} posts from ${digest.channels.length} channels`);\n\nreturn digest;"
      },
      "name": "Prepare Digest",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        1780,
        200
      ],
      "id": "prepare-digest"
    },
    {
      "parameters": {
        "functionCode": "// –û—Ç–ø—Ä–∞–≤–∫–∞ –æ–±—Ä–∞—Ç–Ω–æ –≤ Backend API (–∏–ª–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ)\nconst digest = $json;\n\nconsole.log('üíæ Saving digest to backend...');\nconsole.log('Digest ID:', digest.id);\nconsole.log('Total posts:', digest.total_posts);\nconsole.log('Channels:', digest.channels.length);\n\n// TODO: –ó–¥–µ—Å—å –±—É–¥–µ—Ç —Ä–µ–∞–ª—å–Ω–∞—è –æ—Ç–ø—Ä–∞–≤–∫–∞ –≤ Backend API\n// –ü–æ–∫–∞ –ø—Ä–æ—Å—Ç–æ –ª–æ–≥–∏—Ä—É–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç\n\nreturn {\n  success: true,\n  digest_id: digest.id,\n  message: `Digest saved with ${digest.total_posts} posts from ${digest.channels.length} channels`,\n  timestamp: new Date().toISOString()\n};"
      },
      "name": "Save to Backend",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        2000,
        200
      ],
      "id": "save-to-backend"
    },
    {
      "parameters": {
        "functionCode": "// –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–ª—É—á–∞—è –∫–æ–≥–¥–∞ –Ω–µ—Ç –ø–æ—Å—Ç–æ–≤\nconsole.log('‚ö†Ô∏è No posts received from userbot');\n\nreturn {\n  success: false,\n  message: 'No posts to process',\n  timestamp: new Date().toISOString()\n};"
      },
      "name": "No Posts Handler",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [
        900,
        400
      ],
      "id": "no-posts-handler"
    }
  ],
  "connections": {
    "Webhook - Receive Posts": {
      "main": [
        [
          {
            "node": "Process & Log Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process & Log Data": {
      "main": [
        [
          {
            "node": "Has Posts?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Has Posts?": {
      "main": [
        [
          {
            "node": "Group by Channels",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "No Posts Handler",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Group by Channels": {
      "main": [
        [
          {
            "node": "Prepare for AI",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare for AI": {
      "main": [
        [
          {
            "node": "OpenAI Analysis",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Analysis": {
      "main": [
        [
          {
            "node": "Process AI Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process AI Results": {
      "main": [
        [
          {
            "node": "Prepare Digest",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Digest": {
      "main": [
        [
          {
            "node": "Save to Backend",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": true,
  "settings": {},
  "versionId": "3"
} 