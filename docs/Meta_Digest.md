# Мета-Дайджест: Эволюция Агрегации Новостей через Иерархическую Кластеризацию и DAG

## 1. Краткое описание
Мета-дайджест — это эволюционное развитие системы агрегации и обработки новостей, где существующие саммари постов (из Telegram-каналов или абстрактных источников) преобразуются в динамическую иерархическую структуру. Вместо линейного списка саммари, система строит Directed Acyclic Graph (DAG), где заметки группируются в кластеры по семантическому сходству, с обобщающими суммами (мета-саммари) на каждом уровне. Это позволяет пользователям "исследовать" новости как сеть тем: от общих рубрик (top-level) к детальным подтемам и конкретным заметкам. Визуализация графа интерактивна, с анимацией перестройки при новых данных, зумом по уровням и hover для деталей. Архитектура мультитенантна, интегрируется с существующей системой (processed_data, Orchestrator), и ориентирована на user-facing UI (альтернатива текстовым дайджестам в ботах).

## 2. Текущая проблематика (неудобность формата ленты из саммари)
Текущий формат дайджестов как линейной ленты саммари имеет несколько ограничений, особенно для разнообразных заметок (короткие реплики, средние тексты, длинные обзоры):
- **Неравномерность подачи**: Саммари адаптивны по длине (короткие для простых постов, длинные для сложных), но в ленте это выглядит хаотично — "высушенные" суммы теряют нюансы, а детальные перегружают.
- **Линейность и утомляемость**: Структура как список категорий (Тема 1: саммари1, саммари2; Тема 2: ...) — монотонна, особенно для длинных дайджестов. Нет "глубины" для навигации по подтемам.
- **Пересечения и неточность категорий**: Фиксированные категории (настроенные редактором) часто пересекаются (e.g., "война" vs "война в Украине" vs "новости США"), приводя к неоднозначной категоризации. Часть заметок "падает между" темами, а многотемные посты (e.g., техника + геополитика) не отражают реальные связи.
- **Потеря контекста**: Нет визуального обзора связей между темами, что делает дайджест менее engaging и информативным для пользователей, желающих "погрузиться" в события.

Это приводит к снижению вовлечённости: дайджест как "стена текста", а не интерактивная карта новостей.

## 3. Постановка задачи: что мы намерены сделать
Цель — создать мета-дайджест как альтернативу линейным дайджестам: на основе саммари заметок генерировать эмбеддинги, кластеризовать их в динамический DAG (с множественной принадлежностью узлов и весами рёбер), обогащать узлы мета-саммари и визуализировать как интерактивный граф. Ключевые фичи:
- Динамическая иерархия (3-5 уровней, определяемых данными по инерции и threshold).
- Пересечения тем (DAG, не дерево) для отражения реальных связей.
- Анимационная перестройка графа при новых данных (локальная/глобальная).
- User-facing UI: Страница с графом, текстом узла (с хлебными крошками), настройками и логом, доступная из бота (WebView или ссылка).
- Мультитенантность: Per-bot, с персонализацией (фильтры по urgency, фокус на узле).
- Результат: Дайджест как "живая сеть тем" — от общих рубрик к деталям, с визуализацией для исследования.

## 4. Архитектура (описание модулей, что за что отвечает)
Архитектура разделена на backend (обработка и хранение) и frontend (визуализация и взаимодействие). Backend расширяет существующий стек (Orchestrator, processed_data), frontend — новая страница на React для пользователей ботов.

- **Backend**:
  - **Embeddings Module**: Отвечает за генерацию и хранение эмбеддингов саммари (демон проверяет обновления в БД, воркер обрабатывает новые записи).
  - **DAG Builder Module**: Строит и обновляет DAG (добавление элементов, перестройка с инерцией, эндпоинты для JSON-выдачи).
  - **Node Summarizer Module**: Генерирует мета-саммари для узлов DAG (сервисная функция, вызываемая из DAG Builder).

- **Frontend**:
  - **Graph Area (a)**: Визуализация DAG с анимацией, зумом по уровням и фокусом на узлах.
  - **Node Text Area (b)**: Отображение текста выбранного узла с хлебными крошками (родители сверху, дети снизу) и кликабельной навигацией.
  - **Settings Area (c)**: Настройки просмотра (threshold, фильтры, unlock focus).
  - **Log Area (d)**: Логи изменений (что перестроено, время, ошибки) для отладки и прозрачности.

Модули взаимодействуют: Embeddings → DAG Builder (триггер на обновления) → Node Summarizer (для обогащения) → Frontend (JSON через эндпоинты).

## 5. Интеграция с существующей архитектурой
Интеграция минимизирует изменения: Используй Orchestrator как центральный хаб для координации (параллельные workers с флагами, e.g., is_embedded после is_summarized). Хранение в основной БД (расширение processed_data для эмбеддингов, новая таблица meta_dags для JSON-графа с bot_id). 

- **С Orchestrator**: Embeddings как новый worker (независимый цикл, аналог categorization/summarization). DAG Builder вызывается post-summarization (после embeddings), с триггером на новые записи.
- **С processed_data**: Добавь column embedding (VECTOR или array/float[]). Фильтруй по bot_id для мультитенантности.
- **С публичными ботами**: UI доступен по ссылке из бота (WebView в TG), с bot_id в URL для загрузки данных.
- **Миграции**: One-time для legacy саммари (ретро-эмбеддинги). Безопасность: Отложить, но базово — проверка подписки (из bot_users).
- **Масштаб**: Инкрементальные обновления (только delta в DAG), cron для полной перестройки (ночью).

Это сохранит систему стабильной: Новая фича как "расширение", не ломает текущие дайджесты.

## 6. Детальное описание каждого модуля
### Embeddings Module
- **Принцип работы**: Демон (циклическая проверка БД каждые 30 сек) детектирует новые/обновлённые саммари (по timestamp или флагу is_summarized=true без embedding). Воркер генерирует эмбеддинги (fixed-size vectors, e.g., 384-1536 dim) на основе саммари, сохраняет в БД. Инкрементально: Только для новых записей, с batch (10-50 за раз).
- **Зависимости**: HuggingFace Transformers/Sentence-Transformers (локальные модели как all-MiniLM-L6-v2 для GPU-ускорения). Интеграция с Orchestrator (как worker с lock для избежания race conditions).
- **Предложения по библиотекам**: Sentence-Transformers (простая, GPU-ready). Для хранения — pgvector (расширение Postgres для vector сходства).
- **Форматы данных и эндпоинты**: Вход — саммари из processed_data (text string). Выход — embedding как array/float[] в БД. Эндпоинт: GET /api/embeddings/status (прогресс по bot_id).
- **Технические детали и замечания**: GPU-ускорение (RTX для batch ~секунды на 100). Обработка ошибок: Retry при LLM-fail, fallback на CPU. Замечание: Для длинных саммари — truncate или average chunks. Мультитенант: Фильтр по bot_id.

### DAG Builder Module
- **Принцип работы**: Принимает эмбеддинги, строит DAG bottom-up (hierarchical clustering с инерцией для динамических уровней). Добавление элементов: Инкрементально (новая вершина → локальная перестройка affected ветвей по threshold). Полная rebuild по cron или если инерция > delta. Выдаёт JSON для фронта.
- **Зависимости**: SciPy/Scikit-learn (linkage для clustering, silhouette для инерции). NetworkX для хранения графа (nodes/edges с weights).
- **Предложения по библиотекам**: SciPy для динамической кластеризации (fcluster с adaptive threshold). NetworkX для DAG-структуры (add_node/edge с attrs как summary/level).
- **Форматы данных и эндпоинты**: Вход — embeddings array по bot_id/период. Выход — JSON {nodes: [{id, level, text, children}], edges: [{from, to, weight}]}. Эндпоинты: POST /api/dag/add (добавь элемент, верни updated JSON); GET /api/dag/{bot_id} (полный граф).
- **Технические детали и замечания**: Weights по cosine similarity (0-1). Пересечения: Множественные родители (DAG-property). Замечание: Limit max depth (5) для производительности; инкремент vs full по инерции delta (>10% — rebuild). Мультитенант: Per-bot rebuild.

### Node Summarizer Module
- **Принцип работы**: Для каждого узла в DAG генерирует мета-саммари на основе "детей" (саммари нижестоящих). Вызывается из DAG Builder (сервисно, после clustering). Адаптирует длину по уровню (короче на top).
- **Зависимости**: LLM-интеграция (как в SummarizationService, с промптами).
- **Предложения по библиотекам**: HuggingFace/Ollama (локальные модели для мета-сумм).
- **Форматы данных и эндпоинты**: Вход — list саммари/эмбеддингов кластера + level. Выход — string мета-суммы, сохранённая в node attrs JSON. Нет отдельного эндпоинта (внутренний вызов).
- **Технические детали и замечания**: Промпт: "Суммируй [list] в [length] знаков, фокус на пересечениях". Хранение: В основной БД (как поле в meta_dags JSONB). Замечание: Batch для уровней; кэш если узел не изменился. Мультитенант: Bot-specific промпты.

### Frontend (Graph/Text/Settings/Log Areas)
- **Принцип работы**: React-страница с resizable/collapsible panels. Graph: Визуализация DAG с анимацией. Text: Детали узла с breadcrumbs. Settings: Фильтры/threshold. Log: Изменения.
- **Зависимости**: Cytoscape.js (граф с zoom/hover/animation). React-resizable для panels.
- **Предложения по библиотекам**: Cytoscape-react (интеграция), react-collapsible (сворачивание).
- **Форматы данных**: JSON от backend (nodes/edges).
- **Технические детали и замечания**: Анимация: Cytoscape transitions. Focus: Lock node position. Мобильный: Adaptive stack. Замечание: WebSocket для updates. Мультитенант: Load по bot_id/user_id.

## 7. Стратегия разработки
Разбей на этапы по принципу MVP: От backend-фундамента к frontend-UX, с итеративным тестированием. Каждый этап — 3-7 дней, с подзадачами, DoD и тестами. Общий timeline: 4-6 недель.

### Этап 1: Backend Embeddings (3-5 дней)
- **Подзадачи**:
  1. Интегрировать демон в Orchestrator (worker для проверки новых саммари).
  2. Реализовать воркер (batch-генерация эмбеддингов, сохранение в БД).
  3. Миграция для legacy данных.
- **Definition of Done**: Демону генерирует эмбеддинги для 100+ саммари, сохранены в processed_data.
- **Тестирование**: Unit: Тест на batch (время <1 мин). Integration: Добавь саммари → проверь embedding в БД. Edge: Пустые обновления (нет ошибок).

### Этап 2: Backend DAG Builder (5-7 дней)
- **Подзадачи**:
  1. Реализовать clustering с инерцией (динамические уровни).
  2. Добавить эндпоинты (add/rebuild/get JSON).
  3. Поддержка весов/пересечений (DAG-property).
- **Definition of Done**: Модуль строит DAG из 200 эмбеддингов, JSON с nodes/edges.
- **Тестирование**: Unit: Тест на добавление вершины (перестройка <10 сек). Integration: Полная rebuild, check инерция. Edge: Пересекающиеся заметки (multiple parents).

### Этап 3: Backend Node Summarizer (3-5 дней)
- **Подзадачи**:
  1. Реализовать функцию генерации мета-сумм (по level/кластеру).
  2. Интегрировать в DAG Builder (вызов после clustering).
  3. Кэш и batch для производительности.
- **Definition of Done**: Мета-суммы генерируются для узлов, адаптивны по длине.
- **Тестирование**: Unit: Тест промпта на кластере (длина ±10%). Integration: Полный DAG с суммами. Edge: Пустой кластер (graceful skip).

### Этап 4: Frontend UI (7-10 дней)
- **Подзадачи**:
  1. Создать React-страницу с resizable panels (areas a-d).
  2. Интегрировать Cytoscape для графа (анимация, zoom, hover, focus-lock).
  3. Реализовать area b (текст с breadcrumbs, кликабельные).
  4. Добавить areas c (фильтры) и d (логи).
  5. WebSocket/polling для updates.
- **Definition of Done**: Страница загружает JSON, визуализирует DAG, поддерживает взаимодействия.
- **Тестирование**: UX: Тест на мобильном (rotate, collapse). Integration: Клик → update areas. Edge: Большой граф (no lag), новые данные (анимация без потери фокуса).

### Этап 5: Полная интеграция и тестирование (5-7 дней)
- **Подзадачи**:
  1. Связать с Orchestrator/userbot (триггеры на обновления).
  2. Добавить мультитенант-фильтры (bot_id in URL).
  3. Тестировать end-to-end (новая заметка → DAG update → UI morph).
- **Definition of Done**: Система работает от заметки до визуала, мультитенантна.
- **Тестирование**: End-to-end: Добавь 50 заметок, check перестройку. Performance: Время <5 мин на 1000. UX: User scenarios (zoom/focus). Edge: Пиковые нагрузки, empty data.

---

Как тебе документ? Если нужно доработать (e.g., добавить диаграммы или уточнить подзадачи для Cursor) — скажи. Или давай к реализации: Что сначала — embeddings в backend?