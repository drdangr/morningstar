from fastapi import FastAPI, HTTPException, Depends, status
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
from sqlalchemy import create_engine, Column, Integer, String, Boolean, Text, DateTime, ForeignKey, Table, Float
from sqlalchemy.dialects.postgresql import JSONB
from sqlalchemy.orm import declarative_base
from sqlalchemy.orm import sessionmaker, Session, relationship
from sqlalchemy.sql import func
from pydantic import BaseModel, Field
from typing import List, Optional
from datetime import datetime
import os
from dotenv import load_dotenv
from typing import Dict, Any, Union
import json
from urllib.parse import quote_plus

# –ó–∞–≥—Ä—É–∑–∫–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è
load_dotenv()

# –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
DB_HOST = "127.0.0.1"  # –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ IPv4 –≤–º–µ—Å—Ç–æ localhost
DB_PORT = os.getenv("DB_PORT", "5432")
DB_NAME = os.getenv("DB_NAME", "digest_bot")
DB_USER = os.getenv("DB_USER", "digest_bot")
DB_PASSWORD = os.getenv("DB_PASSWORD", "Demiurg12@")  # –ü—Ä–∞–≤–∏–ª—å–Ω—ã–π –¥–µ—Ñ–æ–ª—Ç

# URL –∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏–µ –ø–∞—Ä–æ–ª—è –¥–ª—è —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã—Ö —Å–∏–º–≤–æ–ª–æ–≤
encoded_password = quote_plus(DB_PASSWORD) if DB_PASSWORD else ""
DATABASE_URL = f"postgresql://{DB_USER}:{encoded_password}@{DB_HOST}:{DB_PORT}/{DB_NAME}"

# Fallback –∫ SQLite –µ—Å–ª–∏ PostgreSQL –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω
SQLITE_FALLBACK = f"sqlite:///{os.path.dirname(os.path.abspath(__file__))}/morningstar.db"

# –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ç–∏–ø –ë–î –¥–ª—è –≤—ã–±–æ—Ä–∞ –ø—Ä–∞–≤–∏–ª—å–Ω—ã—Ö —Ç–∏–ø–æ–≤ –¥–∞–Ω–Ω—ã—Ö
USE_POSTGRESQL = False

try:
    test_engine = create_engine(DATABASE_URL, echo=False)
    # –¢–µ—Å—Ç–∏—Ä—É–µ–º —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ
    with test_engine.connect() as conn:
        from sqlalchemy import text
        conn.execute(text("SELECT 1"))
    print(f"‚úÖ –ü–æ–¥–∫–ª—é—á–µ–Ω –∫ PostgreSQL: {DB_HOST}:{DB_PORT}/{DB_NAME}")
    USE_POSTGRESQL = True
    engine = test_engine
except Exception as e:
    print(f"‚ö†Ô∏è PostgreSQL –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω: {str(e)[:100]}...")
    print("üîÑ –ü–µ—Ä–µ–∫–ª—é—á–∞–µ–º—Å—è –Ω–∞ SQLite fallback")
    DATABASE_URL = SQLITE_FALLBACK
    USE_POSTGRESQL = False
    engine = create_engine(DATABASE_URL)

SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
Base = declarative_base()

# FastAPI –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ
app = FastAPI(
    title="MorningStar Admin API",
    description="API –¥–ª—è –∞–¥–º–∏–Ω-–ø–∞–Ω–µ–ª–∏ MorningStar Bot",
    version="1.0.0"
)

# CORS middleware –¥–ª—è –∞–¥–º–∏–Ω-–ø–∞–Ω–µ–ª–∏
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:5173", "http://localhost:3000"],  # Vite dev server
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# –ú–æ–¥–µ–ª–∏ SQLAlchemy
channel_categories = Table(
    'channel_categories', Base.metadata,
    Column('channel_id', Integer, ForeignKey('channels.id'), primary_key=True),
    Column('category_id', Integer, ForeignKey('categories.id'), primary_key=True)
)

class Category(Base):
    __tablename__ = "categories"
    
    id = Column(Integer, primary_key=True, index=True)
    category_name = Column(String, nullable=False)  # –ò–∑–º–µ–Ω–µ–Ω–æ: name ‚Üí category_name
    description = Column(Text)
    # emoji = Column(String, default="üìù")  # –£–±—Ä–∞–Ω–æ: –Ω–µ—Ç –≤ –ë–î
    is_active = Column(Boolean, default=True)
    # ai_prompt = Column(Text)  # –£–±—Ä–∞–Ω–æ: –Ω–µ—Ç –≤ –ë–î
    # sort_order = Column(Integer, default=0)  # –£–±—Ä–∞–Ω–æ: –Ω–µ—Ç –≤ –ë–î
    created_at = Column(DateTime, default=func.now())
    updated_at = Column(DateTime, default=func.now(), onupdate=func.now())
    
    # –°–≤—è–∑–∏
    channels = relationship("Channel", secondary=channel_categories, back_populates="categories")

class Channel(Base):
    __tablename__ = "channels"
    
    id = Column(Integer, primary_key=True, index=True)
    channel_name = Column(String, nullable=False)  # –î–æ–±–∞–≤–ª–µ–Ω–æ –ø–æ–ª–µ –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏ —Å –ë–î
    telegram_id = Column(Integer, unique=True, nullable=False)
    username = Column(String)
    title = Column(String, nullable=False)
    description = Column(Text)
    is_active = Column(Boolean, default=True)
    last_parsed = Column(DateTime)
    error_count = Column(Integer, default=0)
    created_at = Column(DateTime, default=func.now())
    updated_at = Column(DateTime, default=func.now(), onupdate=func.now())
    
    # –°–≤—è–∑–∏
    categories = relationship("Category", secondary=channel_categories, back_populates="channels")

class ConfigSetting(Base):
    __tablename__ = "config_settings"
    
    id = Column(Integer, primary_key=True, index=True)
    key = Column(String, unique=True, nullable=False, index=True)
    value = Column(Text)
    value_type = Column(String, default="string")  # string, integer, boolean, float, json
    category = Column(String)
    description = Column(Text)
    is_editable = Column(Boolean, default=True)
    created_at = Column(DateTime, default=func.now())
    updated_at = Column(DateTime, default=func.now(), onupdate=func.now())

class Digest(Base):
    __tablename__ = "digests"
    
    id = Column(Integer, primary_key=True, index=True)
    digest_id = Column(String, unique=True, nullable=False, index=True)  # digest_timestamp –æ—Ç N8N
    total_posts = Column(Integer, default=0)
    channels_processed = Column(Integer, default=0)
    original_posts = Column(Integer, default=0)
    relevant_posts = Column(Integer, default=0)
    avg_importance = Column(Float, default=0.0)
    avg_urgency = Column(Float, default=0.0)
    avg_significance = Column(Float, default=0.0)
    binary_relevance_applied = Column(Boolean, default=False)
    with_metrics = Column(Boolean, default=False)
    digest_data = Column(Text)  # JSON –¥–∞–Ω–Ω—ã–µ –ø–æ–ª–Ω–æ–≥–æ –¥–∞–π–¥–∂–µ—Å—Ç–∞
    processed_at = Column(DateTime)
    created_at = Column(DateTime, default=func.now())
    updated_at = Column(DateTime, default=func.now(), onupdate=func.now())

# –¢–∞–±–ª–∏—Ü–∞ —Å–≤—è–∑–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –∏ –∫–∞—Ç–µ–≥–æ—Ä–∏–π (–ø–æ–¥–ø–∏—Å–∫–∏)
user_subscriptions = Table(
    'user_subscriptions', Base.metadata,
    Column('user_id', Integer, ForeignKey('users.id'), primary_key=True),
    Column('category_id', Integer, ForeignKey('categories.id'), primary_key=True)
)

class User(Base):
    __tablename__ = "users"
    
    id = Column(Integer, primary_key=True, index=True)
    telegram_id = Column(Integer, unique=True, nullable=False, index=True)
    username = Column(String)
    first_name = Column(String)
    last_name = Column(String)
    language_code = Column(String, default="ru")
    is_active = Column(Boolean, default=True)
    last_activity = Column(DateTime)
    created_at = Column(DateTime, default=func.now())
    updated_at = Column(DateTime, default=func.now(), onupdate=func.now())
    
    # –°–≤—è–∑–∏
    # –í–†–ï–ú–ï–ù–ù–û –û–¢–ö–õ–Æ–ß–ï–ù–û: subscribed_categories = relationship("Category", secondary=user_subscriptions, back_populates="subscribers")

class PostCache(Base):
    __tablename__ = "posts_cache"
    
    id = Column(Integer, primary_key=True, index=True)
    channel_telegram_id = Column(Integer, nullable=False, index=True)
    telegram_message_id = Column(Integer, nullable=False)
    title = Column(Text)
    content = Column(Text)
    # –£—Å–ª–æ–≤–Ω—ã–µ —Ç–∏–ø—ã –¥–∞–Ω–Ω—ã—Ö –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –ë–î
    media_urls = Column(JSONB if USE_POSTGRESQL else Text, default=[] if USE_POSTGRESQL else "[]")
    views = Column(Integer, default=0)
    post_date = Column(DateTime, nullable=False)
    collected_at = Column(DateTime, default=func.now(), nullable=False)
    userbot_metadata = Column(JSONB if USE_POSTGRESQL else Text, default={} if USE_POSTGRESQL else "{}")
    processing_status = Column(String, default="pending")  # pending, processing, completed, failed

# –û–±–Ω–æ–≤–ª—è–µ–º –º–æ–¥–µ–ª—å Category –¥–ª—è —Å–≤—è–∑–∏ —Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º–∏
# –í–†–ï–ú–ï–ù–ù–û –û–¢–ö–õ–Æ–ß–ï–ù–û –î–û –ò–°–ü–†–ê–í–õ–ï–ù–ò–Ø –°–¢–†–£–ö–¢–£–†–´ –¢–ê–ë–õ–ò–¶–´ user_subscriptions:
# Category.subscribers = relationship("User", secondary=user_subscriptions, back_populates="subscribed_categories")

# –í–†–ï–ú–ï–ù–ù–û –û–¢–ö–õ–Æ–ß–ê–ï–ú –°–í–Ø–ó–¨ –í USER –ú–û–î–ï–õ–ò:
# subscribed_categories = relationship("Category", secondary=user_subscriptions, back_populates="subscribers")

# Dependency –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Å–µ—Å—Å–∏–∏ –ë–î
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

# –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –Ω–∞—á–∞–ª—å–Ω—ã—Ö –Ω–∞—Å—Ç—Ä–æ–µ–∫
def create_default_settings():
    """–°–æ–∑–¥–∞—Ç—å –Ω–∞—á–∞–ª—å–Ω—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ —Å–∏—Å—Ç–µ–º—ã"""
    db = SessionLocal()
    try:
        # –ü–æ–ª—É—á–∞–µ–º —Å–ø–∏—Å–æ–∫ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏—Ö –∫–ª—é—á–µ–π –Ω–∞—Å—Ç—Ä–æ–µ–∫
        existing_keys = {setting.key for setting in db.query(ConfigSetting).all()}
        print(f"–ù–∞–π–¥–µ–Ω–æ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏—Ö –Ω–∞—Å—Ç—Ä–æ–µ–∫: {len(existing_keys)}")
        print(f"–°—É—â–µ—Å—Ç–≤—É—é—â–∏–µ –∫–ª—é—á–∏: {existing_keys}")
        
        default_settings = [
            {
                "key": "CHECK_INTERVAL",
                "value": "30",
                "value_type": "integer",
                "category": "system",
                "description": "–ò–Ω—Ç–µ—Ä–≤–∞–ª –ø—Ä–æ–≤–µ—Ä–∫–∏ –∫–∞–Ω–∞–ª–æ–≤ –≤ –º–∏–Ω—É—Ç–∞—Ö",
                "is_editable": True
            },
            {
                "key": "MAX_POSTS_PER_DIGEST",
                "value": "10",
                "value_type": "integer",
                "category": "digest",
                "description": "–ú–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ—Å—Ç–æ–≤ –≤ –¥–∞–π–¥–∂–µ—Å—Ç–µ",
                "is_editable": True
            },
            {
                "key": "DIGEST_GENERATION_TIME",
                "value": "09:00",
                "value_type": "string",
                "category": "digest",
                "description": "–í—Ä–µ–º—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –¥–∞–π–¥–∂–µ—Å—Ç–æ–≤",
                "is_editable": True
            },
            {
                "key": "AI_MODEL",
                "value": "gpt-4",
                "value_type": "string",
                "category": "ai",
                "description": "–ú–æ–¥–µ–ª—å AI –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∫–æ–Ω—Ç–µ–Ω—Ç–∞",
                "is_editable": True
            },
            {
                "key": "MAX_SUMMARY_LENGTH",
                "value": "150",
                "value_type": "integer",
                "category": "ai",
                "description": "–ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è –¥–ª–∏–Ω–∞ summary –≤ —Å–∏–º–≤–æ–ª–∞—Ö",
                "is_editable": True
            },
            {
                "key": "ENABLE_NOTIFICATIONS",
                "value": "true",
                "value_type": "boolean",
                "category": "system",
                "description": "–í–∫–ª—é—á–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞",
                "is_editable": True
            },
            {
                "key": "LOG_LEVEL",
                "value": "INFO",
                "value_type": "string",
                "category": "system",
                "description": "–£—Ä–æ–≤–µ–Ω—å –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è (DEBUG, INFO, WARNING, ERROR)",
                "is_editable": True
            },
            {
                "key": "BACKUP_RETENTION_DAYS",
                "value": "30",
                "value_type": "integer",
                "category": "system",
                "description": "–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–Ω–µ–π —Ö—Ä–∞–Ω–µ–Ω–∏—è —Ä–µ–∑–µ—Ä–≤–Ω—ã—Ö –∫–æ–ø–∏–π",
                "is_editable": True
            },
            {
                "key": "COLLECTION_DEPTH_DAYS",
                "value": "3",
                "value_type": "integer",
                "category": "system",
                "description": "–°–∫–æ–ª—å–∫–æ –¥–Ω–µ–π –Ω–∞–∑–∞–¥ —Å–æ–±–∏—Ä–∞—Ç—å –ø–æ—Å—Ç—ã –∏–∑ –∫–∞–Ω–∞–ª–æ–≤",
                "is_editable": True
            },
            {
                "key": "MAX_POSTS_PER_CHANNEL",
                "value": "50",
                "value_type": "integer",
                "category": "system",
                "description": "–ú–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ—Å—Ç–æ–≤ —Å –æ–¥–Ω–æ–≥–æ –∫–∞–Ω–∞–ª–∞",
                "is_editable": True
            },
            {
                "key": "MAX_POSTS_FOR_AI_ANALYSIS",
                "value": "10",
                "value_type": "integer",
                "category": "ai",
                "description": "–ú–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ—Å—Ç–æ–≤ –¥–ª—è AI –∞–Ω–∞–ª–∏–∑–∞",
                "is_editable": True
            }
        ]
        
        # –î–æ–±–∞–≤–ª—è–µ–º —Ç–æ–ª—å–∫–æ –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—â–∏–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏
        added_count = 0
        for setting_data in default_settings:
            if setting_data["key"] not in existing_keys:
                db_setting = ConfigSetting(**setting_data)
                db.add(db_setting)
                added_count += 1
                print(f"–î–æ–±–∞–≤–ª–µ–Ω–∞ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞: {setting_data['key']}")
        
        if added_count > 0:
            db.commit()
            print(f"–î–æ–±–∞–≤–ª–µ–Ω–æ {added_count} –Ω–æ–≤—ã—Ö –Ω–∞—Å—Ç—Ä–æ–µ–∫")
        else:
            print("–í—Å–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É—é—Ç")
        
    except Exception as e:
        print(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –Ω–∞—á–∞–ª—å–Ω—ã—Ö –Ω–∞—Å—Ç—Ä–æ–µ–∫: {e}")
        db.rollback()
    finally:
        db.close()

# –°–æ–∑–¥–∞–µ–º –Ω–∞—á–∞–ª—å–Ω—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ
create_default_settings()

# Pydantic –º–æ–¥–µ–ª–∏
class CategoryBase(BaseModel):
    category_name: str = Field(..., min_length=1, max_length=255)  # –ò–∑–º–µ–Ω–µ–Ω–æ: name ‚Üí category_name
    description: Optional[str] = None
    # emoji: str = Field("üìù", max_length=10)  # –£–±—Ä–∞–Ω–æ: –Ω–µ—Ç –≤ –ë–î
    is_active: bool = True
    # ai_prompt: Optional[str] = None  # –£–±—Ä–∞–Ω–æ: –Ω–µ—Ç –≤ –ë–î
    # sort_order: int = 0  # –£–±—Ä–∞–Ω–æ: –Ω–µ—Ç –≤ –ë–î

class CategoryCreate(CategoryBase):
    pass

class CategoryUpdate(CategoryBase):
    pass

class CategoryResponse(CategoryBase):
    id: int
    created_at: datetime
    updated_at: datetime
    
    class Config:
        from_attributes = True

class ChannelBase(BaseModel):
    channel_name: str = Field(..., min_length=1, max_length=255)  # –û—Å–Ω–æ–≤–Ω–æ–µ –ø–æ–ª–µ –¥–ª—è –ë–î
    telegram_id: int
    username: Optional[str] = None
    title: Optional[str] = None  # –°–¥–µ–ª–∞–Ω–æ –æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–º, —Ç.–∫. –∏—Å–ø–æ–ª—å–∑—É–µ–º channel_name
    description: Optional[str] = None
    is_active: bool = True

class ChannelCreate(ChannelBase):
    pass

class ChannelUpdate(ChannelBase):
    pass

class ChannelResponse(ChannelBase):
    id: int
    last_parsed: Optional[datetime] = None
    error_count: int = 0
    created_at: datetime
    updated_at: datetime
    categories: List['CategoryResponse'] = []
    
    class Config:
        from_attributes = True

class ConfigSettingBase(BaseModel):
    key: str = Field(..., min_length=1, max_length=255)
    value: Optional[str] = None
    value_type: str = Field("string", pattern="^(string|integer|boolean|float|json)$")
    category: Optional[str] = None
    description: Optional[str] = None
    is_editable: bool = True

class ConfigSettingCreate(ConfigSettingBase):
    pass

class ConfigSettingUpdate(BaseModel):
    value: Optional[str] = None
    description: Optional[str] = None
    is_editable: Optional[bool] = None

class ConfigSettingResponse(ConfigSettingBase):
    id: int
    created_at: datetime
    updated_at: datetime
    
    class Config:
        from_attributes = True

# Pydantic –º–æ–¥–µ–ª–∏ –¥–ª—è –¥–∞–π–¥–∂–µ—Å—Ç–æ–≤
class DigestCreate(BaseModel):
    digest_id: str = Field(..., min_length=1, max_length=255)
    total_posts: int = Field(0, ge=0)
    channels_processed: int = Field(0, ge=0)
    original_posts: int = Field(0, ge=0)
    relevant_posts: int = Field(0, ge=0)
    avg_importance: float = Field(0.0, ge=0.0, le=10.0)
    avg_urgency: float = Field(0.0, ge=0.0, le=10.0)
    avg_significance: float = Field(0.0, ge=0.0, le=10.0)
    binary_relevance_applied: bool = False
    with_metrics: bool = False
    digest_data: Optional[str] = None  # JSON —Å—Ç—Ä–æ–∫–∞
    processed_at: Optional[datetime] = None

class DigestResponse(DigestCreate):
    id: int
    created_at: datetime
    updated_at: datetime

    class Config:
        from_attributes = True

class DigestSummary(BaseModel):
    """–ö—Ä–∞—Ç–∫–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –¥–∞–π–¥–∂–µ—Å—Ç–µ –¥–ª—è —Å–ø–∏—Å–∫–∞"""
    id: int
    digest_id: str
    total_posts: int
    relevant_posts: int
    channels_processed: int
    avg_importance: float
    processed_at: Optional[datetime]
    created_at: datetime
    
    class Config:
        from_attributes = True

class UserBase(BaseModel):
    telegram_id: int
    username: Optional[str] = None
    first_name: Optional[str] = None
    last_name: Optional[str] = None
    language_code: str = "ru"
    is_active: bool = True

class UserCreate(UserBase):
    pass

class UserUpdate(BaseModel):
    username: Optional[str] = None
    first_name: Optional[str] = None
    last_name: Optional[str] = None
    language_code: Optional[str] = None
    is_active: Optional[bool] = None
    last_activity: Optional[datetime] = None

class UserResponse(UserBase):
    id: int
    last_activity: Optional[datetime] = None
    created_at: datetime
    updated_at: datetime
    subscribed_categories: List['CategoryResponse'] = []
    
    class Config:
        from_attributes = True

class SubscriptionRequest(BaseModel):
    category_ids: List[int] = Field(..., description="–°–ø–∏—Å–æ–∫ ID –∫–∞—Ç–µ–≥–æ—Ä–∏–π –¥–ª—è –ø–æ–¥–ø–∏—Å–∫–∏")

class SubscriptionResponse(BaseModel):
    user_id: int
    subscribed_categories: List['CategoryResponse'] = []
    message: str

class PostCacheBase(BaseModel):
    channel_telegram_id: int
    telegram_message_id: int
    title: Optional[str] = None
    content: Optional[str] = None
    media_urls: Optional[List[str]] = []  # –°–ø–∏—Å–æ–∫ URL –≤ –≤–∏–¥–µ JSONB –º–∞—Å—Å–∏–≤–∞
    views: int = 0
    post_date: datetime
    userbot_metadata: Optional[Dict[str, Any]] = {}  # JSONB –æ–±—ä–µ–∫—Ç
    processing_status: str = "pending"

class PostCacheCreate(PostCacheBase):
    pass

class PostCacheResponse(PostCacheBase):
    id: int
    collected_at: datetime

    class Config:
        from_attributes = True

class PostsBatchCreate(BaseModel):
    """–ú–æ–¥–µ–ª—å –¥–ª—è batch —Å–æ–∑–¥–∞–Ω–∏—è posts –æ—Ç userbot"""
    timestamp: datetime
    collection_stats: Dict[str, Union[int, List[str]]]
    posts: List[PostCacheCreate]
    channels_metadata: Dict[str, Dict[str, Any]]

# ConfigManager –∫–ª–∞—Å—Å
class ConfigManager:
    def __init__(self, db: Session):
        self.db = db
        self.env_vars = dict(os.environ)
    
    def get(self, key: str, default: Any = None) -> Any:
        """–ü–æ–ª—É—á–∏—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ –∏–∑ .env –∏–ª–∏ –ë–î"""
        # –°–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–≤–µ—Ä—è–µ–º .env (–ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç –¥–ª—è —Å–µ–∫—Ä–µ—Ç–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö)
        if key in self.env_vars:
            return self.env_vars[key]
        
        # –ó–∞—Ç–µ–º –ø—Ä–æ–≤–µ—Ä—è–µ–º –ë–î
        db_setting = self.db.query(ConfigSetting).filter(ConfigSetting.key == key).first()
        if db_setting:
            return self._parse_value(db_setting.value, db_setting.value_type)
        
        return default
    
    def set_db_setting(self, key: str, value: str, value_type: str = "string") -> ConfigSetting:
        """–û–±–Ω–æ–≤–∏—Ç—å –∏–ª–∏ —Å–æ–∑–¥–∞—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫—É –≤ –ë–î"""
        db_setting = self.db.query(ConfigSetting).filter(ConfigSetting.key == key).first()
        if db_setting:
            db_setting.value = value
            db_setting.value_type = value_type
            db_setting.updated_at = func.now()
        else:
            db_setting = ConfigSetting(key=key, value=value, value_type=value_type)
            self.db.add(db_setting)
        
        self.db.commit()
        self.db.refresh(db_setting)
        return db_setting
    
    def _parse_value(self, value: str, value_type: str) -> Any:
        """–ü–∞—Ä—Å–∏–Ω–≥ –∑–Ω–∞—á–µ–Ω–∏—è –≤ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–∏ —Å —Ç–∏–ø–æ–º"""
        if value is None:
            return None
        
        try:
            if value_type == "integer":
                return int(value)
            elif value_type == "boolean":
                return value.lower() in ("true", "1", "yes", "on")
            elif value_type == "float":
                return float(value)
            elif value_type == "json":
                return json.loads(value)
            else:  # string
                return value
        except (ValueError, json.JSONDecodeError):
            return value  # –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –∫–∞–∫ —Å—Ç—Ä–æ–∫—É –µ—Å–ª–∏ –ø–∞—Ä—Å–∏–Ω–≥ –Ω–µ —É–¥–∞–ª—Å—è

# –ó–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏
def get_database_size():
    """–ü–æ–ª—É—á–∏—Ç—å —Ä–∞–∑–º–µ—Ä –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –≤ –ú–ë"""
    try:
        # –ò—Å–ø–æ–ª—å–∑—É–µ–º –ø—Ä—è–º–æ–π SQL –∑–∞–ø—Ä–æ—Å –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Ä–∞–∑–º–µ—Ä–∞ –ë–î
        db = SessionLocal()
        result = db.execute(text("SELECT pg_size_pretty(pg_database_size('digest_bot'))")).fetchone()
        size_str = result[0] if result and result[0] else "0 MB"
        
        # –ò–∑–≤–ª–µ–∫–∞–µ–º —á–∏—Å–ª–æ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –≤ –ú–ë
        if "GB" in size_str:
            size_mb = float(size_str.split(" ")[0]) * 1024
        elif "MB" in size_str:
            size_mb = float(size_str.split(" ")[0])
        elif "kB" in size_str:
            size_mb = float(size_str.split(" ")[0]) / 1024
        else:
            size_mb = 0.0
            
        db.close()
        return round(size_mb, 2)
    except Exception as e:
        print(f"Error getting database size: {e}")
        return 0.0

def get_filtered_data_size(channel_ids: list = None):
    """–ü–æ–ª—É—á–∏—Ç—å —Ä–∞–∑–º–µ—Ä –æ—Ç—Ñ–∏–ª—å—Ç—Ä–æ–≤–∞–Ω–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö –≤ –ú–ë"""
    try:
        db = SessionLocal()
        
        # –í—Å–µ–≥–¥–∞ –∏—Å–ø–æ–ª—å–∑—É–µ–º –æ–¥–∏–Ω–∞–∫–æ–≤—É—é –ª–æ–≥–∏–∫—É - —Ä–∞–∑–º–µ—Ä –¥–∞–Ω–Ω—ã—Ö –≤ —Å—Ç—Ä–æ–∫–∞—Ö
        if channel_ids:
            # –†–∞–∑–º–µ—Ä –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã—Ö –∫–∞–Ω–∞–ª–æ–≤
            channel_ids_str = ','.join(map(str, channel_ids))
            query = text(f"""
                SELECT pg_size_pretty(
                    sum(pg_column_size(posts_cache.*))::bigint
                ) 
                FROM posts_cache 
                WHERE channel_telegram_id IN ({channel_ids_str})
            """)
        else:
            # –†–∞–∑–º–µ—Ä –¥–∞–Ω–Ω—ã—Ö –≤–æ –≤—Å–µ—Ö —Å—Ç—Ä–æ–∫–∞—Ö posts_cache (–∞–Ω–∞–ª–æ–≥–∏—á–Ω–æ —Ñ–∏–ª—å—Ç—Ä–æ–≤–∞–Ω–Ω–æ–º—É)
            query = text("""
                SELECT pg_size_pretty(
                    sum(pg_column_size(posts_cache.*))::bigint
                ) 
                FROM posts_cache
            """)
        
        result = db.execute(query).fetchone()
        size_str = result[0] if result and result[0] else "0 bytes"
        
        # –ò–∑–≤–ª–µ–∫–∞–µ–º —á–∏—Å–ª–æ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –≤ –ú–ë
        if "GB" in size_str:
            size_mb = float(size_str.split(" ")[0]) * 1024
        elif "MB" in size_str:
            size_mb = float(size_str.split(" ")[0])
        elif "kB" in size_str:
            size_mb = float(size_str.split(" ")[0]) / 1024
        elif "bytes" in size_str:
            # –î–ª—è –æ—á–µ–Ω—å –º–∞–ª–µ–Ω—å–∫–∏—Ö —Ä–∞–∑–º–µ—Ä–æ–≤ –ø–µ—Ä–µ–≤–æ–¥–∏–º –±–∞–π—Ç—ã –≤ –ú–ë
            bytes_count = float(size_str.split(" ")[0])
            size_mb = bytes_count / (1024 * 1024)
        else:
            size_mb = 0.0
            
        db.close()
        return round(size_mb, 2)
    except Exception as e:
        print(f"Error getting filtered data size: {e}")
        return 0.0

# API Routes –¥–ª—è –∫–∞—Ç–µ–≥–æ—Ä–∏–π
@app.get("/api/categories", response_model=List[CategoryResponse])
def get_categories(
    skip: int = 0,
    limit: int = 100,
    search: Optional[str] = None,
    active_only: bool = False,
    db: Session = Depends(get_db)
):
    """–ü–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –∫–∞—Ç–µ–≥–æ—Ä–∏–π —Å –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å—é –ø–æ–∏—Å–∫–∞ –∏ —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏"""
    query = db.query(Category)
    
    if active_only:
        query = query.filter(Category.is_active == True)
    
    if search:
        query = query.filter(Category.category_name.contains(search))
    
    categories = query.order_by(Category.category_name).offset(skip).limit(limit).all()
    return categories

@app.post("/api/categories", response_model=CategoryResponse, status_code=status.HTTP_201_CREATED)
def create_category(category: CategoryCreate, db: Session = Depends(get_db)):
    """–°–æ–∑–¥–∞—Ç—å –Ω–æ–≤—É—é –∫–∞—Ç–µ–≥–æ—Ä–∏—é"""
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º —É–Ω–∏–∫–∞–ª—å–Ω–æ—Å—Ç—å –∏–º–µ–Ω–∏
    existing = db.query(Category).filter(Category.category_name == category.category_name).first()
    if existing:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="–ö–∞—Ç–µ–≥–æ—Ä–∏—è —Å —Ç–∞–∫–∏–º –∏–º–µ–Ω–µ–º —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç"
        )
    
    db_category = Category(**category.model_dump())
    db.add(db_category)
    db.commit()
    db.refresh(db_category)
    return db_category

@app.get("/api/categories/{category_id}", response_model=CategoryResponse)
def get_category(category_id: int, db: Session = Depends(get_db)):
    """–ü–æ–ª—É—á–∏—Ç—å –∫–∞—Ç–µ–≥–æ—Ä–∏—é –ø–æ ID"""
    category = db.query(Category).filter(Category.id == category_id).first()
    if not category:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="–ö–∞—Ç–µ–≥–æ—Ä–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞"
        )
    return category

@app.put("/api/categories/{category_id}", response_model=CategoryResponse)
def update_category(category_id: int, category: CategoryUpdate, db: Session = Depends(get_db)):
    """–û–±–Ω–æ–≤–∏—Ç—å –∫–∞—Ç–µ–≥–æ—Ä–∏—é"""
    db_category = db.query(Category).filter(Category.id == category_id).first()
    if not db_category:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="–ö–∞—Ç–µ–≥–æ—Ä–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞"
        )
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º —É–Ω–∏–∫–∞–ª—å–Ω–æ—Å—Ç—å –∏–º–µ–Ω–∏ (–∏—Å–∫–ª—é—á–∞—è —Ç–µ–∫—É—â—É—é –∫–∞—Ç–µ–≥–æ—Ä–∏—é)
    existing = db.query(Category).filter(
        Category.category_name == category.category_name,
        Category.id != category_id
    ).first()
    if existing:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="–ö–∞—Ç–µ–≥–æ—Ä–∏—è —Å —Ç–∞–∫–∏–º –∏–º–µ–Ω–µ–º —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç"
        )
    
    for field, value in category.model_dump().items():
        setattr(db_category, field, value)
    
    db.commit()
    db.refresh(db_category)
    return db_category

@app.delete("/api/categories/{category_id}")
def delete_category(category_id: int, db: Session = Depends(get_db)):
    """–£–¥–∞–ª–∏—Ç—å –∫–∞—Ç–µ–≥–æ—Ä–∏—é"""
    category = db.query(Category).filter(Category.id == category_id).first()
    if not category:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="–ö–∞—Ç–µ–≥–æ—Ä–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞"
        )
    
    db.delete(category)
    db.commit()
    return {"message": "–ö–∞—Ç–µ–≥–æ—Ä–∏—è —É—Å–ø–µ—à–Ω–æ —É–¥–∞–ª–µ–Ω–∞"}

# API Routes –¥–ª—è –∫–∞–Ω–∞–ª–æ–≤
@app.get("/api/channels", response_model=List[ChannelResponse])
def get_channels(
    skip: int = 0,
    limit: int = 100,
    search: Optional[str] = None,
    active_only: bool = False,
    db: Session = Depends(get_db)
):
    """–ü–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –∫–∞–Ω–∞–ª–æ–≤ —Å –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å—é –ø–æ–∏—Å–∫–∞ –∏ —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏"""
    from sqlalchemy.orm import selectinload
    
    query = db.query(Channel).options(selectinload(Channel.categories))
    
    if active_only:
        query = query.filter(Channel.is_active == True)
    
    if search:
        query = query.filter(
            Channel.title.contains(search) | 
            Channel.username.contains(search)
        )
    
    channels = query.order_by(Channel.title).offset(skip).limit(limit).all()
    return channels

@app.post("/api/channels", response_model=ChannelResponse, status_code=status.HTTP_201_CREATED)
def create_channel(channel: ChannelCreate, db: Session = Depends(get_db)):
    """–°–æ–∑–¥–∞—Ç—å –Ω–æ–≤—ã–π –∫–∞–Ω–∞–ª"""
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º —É–Ω–∏–∫–∞–ª—å–Ω–æ—Å—Ç—å telegram_id
    existing = db.query(Channel).filter(Channel.telegram_id == channel.telegram_id).first()
    if existing:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="–ö–∞–Ω–∞–ª —Å —Ç–∞–∫–∏–º Telegram ID —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç"
        )
    
    # –°–æ–∑–¥–∞–µ–º –¥–∞–Ω–Ω—ã–µ –¥–ª—è –ë–î —Å –∞–≤—Ç–æ–∑–∞–ø–æ–ª–Ω–µ–Ω–∏–µ–º title
    channel_data = channel.model_dump()
    if not channel_data.get('title'):
        channel_data['title'] = channel_data['channel_name']  # –ó–∞–ø–æ–ª–Ω—è–µ–º title –∏–∑ channel_name
    
    db_channel = Channel(**channel_data)
    db.add(db_channel)
    db.commit()
    db.refresh(db_channel)
    return db_channel

@app.get("/api/channels/{channel_id}", response_model=ChannelResponse)
def get_channel(channel_id: int, db: Session = Depends(get_db)):
    """–ü–æ–ª—É—á–∏—Ç—å –∫–∞–Ω–∞–ª –ø–æ ID"""
    channel = db.query(Channel).filter(Channel.id == channel_id).first()
    if not channel:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="–ö–∞–Ω–∞–ª –Ω–µ –Ω–∞–π–¥–µ–Ω"
        )
    return channel

@app.put("/api/channels/{channel_id}", response_model=ChannelResponse)
def update_channel(channel_id: int, channel: ChannelUpdate, db: Session = Depends(get_db)):
    """–û–±–Ω–æ–≤–∏—Ç—å –∫–∞–Ω–∞–ª"""
    db_channel = db.query(Channel).filter(Channel.id == channel_id).first()
    if not db_channel:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="–ö–∞–Ω–∞–ª –Ω–µ –Ω–∞–π–¥–µ–Ω"
        )
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º —É–Ω–∏–∫–∞–ª—å–Ω–æ—Å—Ç—å telegram_id (–∏—Å–∫–ª—é—á–∞—è —Ç–µ–∫—É—â–∏–π –∫–∞–Ω–∞–ª)
    existing = db.query(Channel).filter(
        Channel.telegram_id == channel.telegram_id,
        Channel.id != channel_id
    ).first()
    if existing:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="–ö–∞–Ω–∞–ª —Å —Ç–∞–∫–∏–º Telegram ID —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç"
        )
    
    # –û–±–Ω–æ–≤–ª—è–µ–º –¥–∞–Ω–Ω—ã–µ —Å –∞–≤—Ç–æ–∑–∞–ø–æ–ª–Ω–µ–Ω–∏–µ–º title
    channel_data = channel.model_dump()
    if not channel_data.get('title'):
        channel_data['title'] = channel_data['channel_name']  # –ó–∞–ø–æ–ª–Ω—è–µ–º title –∏–∑ channel_name
    
    for field, value in channel_data.items():
        setattr(db_channel, field, value)
    
    db.commit()
    db.refresh(db_channel)
    return db_channel

@app.delete("/api/channels/{channel_id}")
def delete_channel(channel_id: int, db: Session = Depends(get_db)):
    """–£–¥–∞–ª–∏—Ç—å –∫–∞–Ω–∞–ª"""
    channel = db.query(Channel).filter(Channel.id == channel_id).first()
    if not channel:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="–ö–∞–Ω–∞–ª –Ω–µ –Ω–∞–π–¥–µ–Ω"
        )
    
    db.delete(channel)
    db.commit()
    return {"message": "–ö–∞–Ω–∞–ª —É—Å–ø–µ—à–Ω–æ —É–¥–∞–ª–µ–Ω"}

@app.post("/api/channels/validate")
async def validate_channel(request: dict):
    """–í–∞–ª–∏–¥–∞—Ü–∏—è –∫–∞–Ω–∞–ª–∞ –∏ –ø–æ–ª—É—á–µ–Ω–∏–µ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–π –¥–ª—è –∞–≤—Ç–æ–∑–∞–ø–æ–ª–Ω–µ–Ω–∏—è"""
    try:
        user_input = request.get('channel_input', '').strip()
        if not user_input:
            return {
                'success': False,
                'error': '–í–≤–µ–¥–∏—Ç–µ username, —Å—Å—ã–ª–∫—É –∏–ª–∏ Telegram ID –∫–∞–Ω–∞–ª–∞',
                'data': None
            }
        
        # –ò–º–ø–æ—Ä—Ç –º–æ–¥—É–ª—è –≤–∞–ª–∏–¥–∞—Ü–∏–∏
        from channel_validator import validate_channel_for_api
        
        result = await validate_channel_for_api(user_input)
        
        if result['validation']['valid']:
            suggestions = result['suggestions']
            return {
                'success': True,
                'data': {
                    'title': suggestions.get('title'),
                    'username': suggestions.get('username'),
                    'description': suggestions.get('description'),
                    'telegram_id': suggestions.get('telegram_id'),
                    'subscribers': getattr(result, 'subscribers_count', None)
                },
                'message': '–ö–∞–Ω–∞–ª —É—Å–ø–µ—à–Ω–æ –Ω–∞–π–¥–µ–Ω –∏ –ø—Ä–æ–≤–µ—Ä–µ–Ω'
            }
        else:
            warnings = result['validation']['warnings']
            error_message = warnings[0] if warnings else '–ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ–≤–µ—Ä–∏—Ç—å –∫–∞–Ω–∞–ª'
            return {
                'success': False,
                'error': error_message,
                'data': None
            }
        
    except Exception as e:
        return {
            'success': False,
            'error': f'–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏: {str(e)}',
            'data': None
        }

# –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ endpoints
@app.get("/api/health")
def health_check():
    """–ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–æ—Å—Ç–æ—è–Ω–∏—è API"""
    return {"status": "ok", "timestamp": datetime.now()}

@app.get("/api/stats")
def get_stats(db: Session = Depends(get_db)):
    """–ü–æ–ª—É—á–∏—Ç—å –±–∞–∑–æ–≤—É—é —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É"""
    categories_count = db.query(Category).count()
    channels_count = db.query(Channel).count()
    active_categories = db.query(Category).filter(Category.is_active == True).count()
    active_channels = db.query(Channel).filter(Channel.is_active == True).count()
    digests_count = db.query(Digest).count()
    posts_total = db.query(PostCache).count()
    posts_pending = db.query(PostCache).filter(PostCache.processing_status == "pending").count()
    posts_processed = db.query(PostCache).filter(PostCache.processing_status == "completed").count()
    
    # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —Å–≤—è–∑–µ–π
    total_links = db.query(channel_categories).count()
    
    # –†–∞–∑–º–µ—Ä –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
    database_size = get_database_size()
    
    return {
        "total_categories": categories_count,
        "active_categories": active_categories,
        "total_channels": channels_count,
        "active_channels": active_channels,
        "total_digests": digests_count,
        "total_posts": posts_total,
        "posts_pending": posts_pending,
        "posts_processed": posts_processed,
        "channel_category_links": total_links,
        "database_size_mb": database_size
    }

# API –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è —Å–≤—è–∑—è–º–∏ –∫–∞–Ω–∞–ª-–∫–∞—Ç–µ–≥–æ—Ä–∏—è
@app.get("/api/channels/{channel_id}/categories", response_model=List[CategoryResponse])
def get_channel_categories(channel_id: int, db: Session = Depends(get_db)):
    """–ü–æ–ª—É—á–∏—Ç—å –≤—Å–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ –∫–∞–Ω–∞–ª–∞"""
    channel = db.query(Channel).filter(Channel.id == channel_id).first()
    if not channel:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="–ö–∞–Ω–∞–ª –Ω–µ –Ω–∞–π–¥–µ–Ω"
        )
    return channel.categories

@app.post("/api/channels/{channel_id}/categories/{category_id}")
def add_category_to_channel(channel_id: int, category_id: int, db: Session = Depends(get_db)):
    """–î–æ–±–∞–≤–∏—Ç—å –∫–∞—Ç–µ–≥–æ—Ä–∏—é –∫ –∫–∞–Ω–∞–ª—É"""
    channel = db.query(Channel).filter(Channel.id == channel_id).first()
    if not channel:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="–ö–∞–Ω–∞–ª –Ω–µ –Ω–∞–π–¥–µ–Ω"
        )
    
    category = db.query(Category).filter(Category.id == category_id).first()
    if not category:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="–ö–∞—Ç–µ–≥–æ—Ä–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞"
        )
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —Å–≤—è–∑—å –µ—â–µ –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
    if category in channel.categories:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="–ö–∞—Ç–µ–≥–æ—Ä–∏—è —É–∂–µ –ø—Ä–∏–≤—è–∑–∞–Ω–∞ –∫ —ç—Ç–æ–º—É –∫–∞–Ω–∞–ª—É"
        )
    
    channel.categories.append(category)
    db.commit()
    
    return {"message": "–ö–∞—Ç–µ–≥–æ—Ä–∏—è —É—Å–ø–µ—à–Ω–æ –¥–æ–±–∞–≤–ª–µ–Ω–∞ –∫ –∫–∞–Ω–∞–ª—É"}

@app.delete("/api/channels/{channel_id}/categories/{category_id}")
def remove_category_from_channel(channel_id: int, category_id: int, db: Session = Depends(get_db)):
    """–£–¥–∞–ª–∏—Ç—å –∫–∞—Ç–µ–≥–æ—Ä–∏—é –æ—Ç –∫–∞–Ω–∞–ª–∞"""
    channel = db.query(Channel).filter(Channel.id == channel_id).first()
    if not channel:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="–ö–∞–Ω–∞–ª –Ω–µ –Ω–∞–π–¥–µ–Ω"
        )
    
    category = db.query(Category).filter(Category.id == category_id).first()
    if not category:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="–ö–∞—Ç–µ–≥–æ—Ä–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞"
        )
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —Å–≤—è–∑—å —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
    if category not in channel.categories:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="–ö–∞—Ç–µ–≥–æ—Ä–∏—è –Ω–µ –ø—Ä–∏–≤—è–∑–∞–Ω–∞ –∫ —ç—Ç–æ–º—É –∫–∞–Ω–∞–ª—É"
        )
    
    channel.categories.remove(category)
    db.commit()
    
    return {"message": "–ö–∞—Ç–µ–≥–æ—Ä–∏—è —É—Å–ø–µ—à–Ω–æ —É–¥–∞–ª–µ–Ω–∞ –æ—Ç –∫–∞–Ω–∞–ª–∞"}

@app.get("/api/categories/{category_id}/channels", response_model=List[ChannelResponse])
def get_category_channels(category_id: int, db: Session = Depends(get_db)):
    """–ü–æ–ª—É—á–∏—Ç—å –≤—Å–µ –∫–∞–Ω–∞–ª—ã –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–π –∫–∞—Ç–µ–≥–æ—Ä–∏–∏"""
    category = db.query(Category).filter(Category.id == category_id).first()
    if not category:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="–ö–∞—Ç–µ–≥–æ—Ä–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞"
        )
    return category.channels

# API –¥–ª—è –Ω–∞—Å—Ç—Ä–æ–µ–∫ —Å–∏—Å—Ç–µ–º—ã
@app.get("/api/settings", response_model=List[ConfigSettingResponse])
def get_settings(
    category: Optional[str] = None,
    editable_only: bool = False,
    db: Session = Depends(get_db)
):
    """–ü–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –Ω–∞—Å—Ç—Ä–æ–µ–∫ —Å –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å—é —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏"""
    query = db.query(ConfigSetting)
    
    if category:
        query = query.filter(ConfigSetting.category == category)
    
    if editable_only:
        query = query.filter(ConfigSetting.is_editable == True)
    
    settings = query.order_by(ConfigSetting.category, ConfigSetting.key).all()
    return settings

@app.get("/api/settings/categories")
def get_setting_categories():
    """–ü–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –≤—Å–µ—Ö –∫–∞—Ç–µ–≥–æ—Ä–∏–π –Ω–∞—Å—Ç—Ä–æ–µ–∫"""
    # –í—Ä–µ–º–µ–Ω–Ω–∞—è –∑–∞–≥–ª—É—à–∫–∞ —Å –æ—Å–Ω–æ–≤–Ω—ã–º–∏ –∫–∞—Ç–µ–≥–æ—Ä–∏—è–º–∏
    return {"categories": ["system", "digest", "ai"]}

@app.post("/api/settings", response_model=ConfigSettingResponse, status_code=status.HTTP_201_CREATED)
def create_setting(setting: ConfigSettingCreate, db: Session = Depends(get_db)):
    """–°–æ–∑–¥–∞—Ç—å –Ω–æ–≤—É—é –Ω–∞—Å—Ç—Ä–æ–π–∫—É"""
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º —É–Ω–∏–∫–∞–ª—å–Ω–æ—Å—Ç—å –∫–ª—é—á–∞
    existing = db.query(ConfigSetting).filter(ConfigSetting.key == setting.key).first()
    if existing:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="–ù–∞—Å—Ç—Ä–æ–π–∫–∞ —Å —Ç–∞–∫–∏–º –∫–ª—é—á–æ–º —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç"
        )
    
    db_setting = ConfigSetting(**setting.model_dump())
    db.add(db_setting)
    db.commit()
    db.refresh(db_setting)
    return db_setting

@app.get("/api/settings/{setting_id}", response_model=ConfigSettingResponse)
def get_setting(setting_id: int, db: Session = Depends(get_db)):
    """–ü–æ–ª—É—á–∏—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫—É –ø–æ ID"""
    setting = db.query(ConfigSetting).filter(ConfigSetting.id == setting_id).first()
    if not setting:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="–ù–∞—Å—Ç—Ä–æ–π–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞"
        )
    return setting

@app.put("/api/settings/{setting_id}", response_model=ConfigSettingResponse)
def update_setting(setting_id: int, setting: ConfigSettingUpdate, db: Session = Depends(get_db)):
    """–û–±–Ω–æ–≤–∏—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫—É"""
    db_setting = db.query(ConfigSetting).filter(ConfigSetting.id == setting_id).first()
    if not db_setting:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="–ù–∞—Å—Ç—Ä–æ–π–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞"
        )
    
    # –û–±–Ω–æ–≤–ª—è–µ–º —Ç–æ–ª—å–∫–æ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª–µ–Ω–Ω—ã–µ –ø–æ–ª—è
    for field, value in setting.model_dump(exclude_unset=True).items():
        setattr(db_setting, field, value)
    
    db.commit()
    db.refresh(db_setting)
    return db_setting

@app.delete("/api/settings/{setting_id}")
def delete_setting(setting_id: int, db: Session = Depends(get_db)):
    """–£–¥–∞–ª–∏—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫—É"""
    setting = db.query(ConfigSetting).filter(ConfigSetting.id == setting_id).first()
    if not setting:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="–ù–∞—Å—Ç—Ä–æ–π–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞"
        )
    
    db.delete(setting)
    db.commit()
    return {"message": "–ù–∞—Å—Ç—Ä–æ–π–∫–∞ —É—Å–ø–µ—à–Ω–æ —É–¥–∞–ª–µ–Ω–∞"}

# Endpoint –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ —á–µ—Ä–µ–∑ ConfigManager
@app.get("/api/config/{key}")
def get_config_value(key: str, db: Session = Depends(get_db)):
    """–ü–æ–ª—É—á–∏—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ —á–µ—Ä–µ–∑ ConfigManager"""
    config = ConfigManager(db)
    value = config.get(key)
    
    if value is None:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="–ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞"
        )
    
    return {"key": key, "value": value}

# API –¥–ª—è –¥–∞–π–¥–∂–µ—Å—Ç–æ–≤
@app.post("/api/digests", response_model=DigestResponse, status_code=status.HTTP_201_CREATED)
def create_digest(digest: DigestCreate, db: Session = Depends(get_db)):
    """–°–æ–∑–¥–∞—Ç—å –Ω–æ–≤—ã–π –¥–∞–π–¥–∂–µ—Å—Ç (endpoint –¥–ª—è N8N)"""
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º —É–Ω–∏–∫–∞–ª—å–Ω–æ—Å—Ç—å digest_id
    existing = db.query(Digest).filter(Digest.digest_id == digest.digest_id).first()
    if existing:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="–î–∞–π–¥–∂–µ—Å—Ç —Å —Ç–∞–∫–∏–º ID —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç"
        )
    
    db_digest = Digest(**digest.model_dump())
    db.add(db_digest)
    db.commit()
    db.refresh(db_digest)
    return db_digest

@app.get("/api/digests", response_model=List[DigestSummary])
def get_digests(
    skip: int = 0,
    limit: int = 100,
    db: Session = Depends(get_db)
):
    """–ü–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –¥–∞–π–¥–∂–µ—Å—Ç–æ–≤ (–∫—Ä–∞—Ç–∫–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è)"""
    digests = db.query(Digest).order_by(Digest.created_at.desc()).offset(skip).limit(limit).all()
    return digests

@app.get("/api/digests/{digest_id}", response_model=DigestResponse)
def get_digest(digest_id: str, db: Session = Depends(get_db)):
    """–ü–æ–ª—É—á–∏—Ç—å –ø–æ–ª–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –¥–∞–π–¥–∂–µ—Å—Ç–µ"""
    digest = db.query(Digest).filter(Digest.digest_id == digest_id).first()
    if not digest:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="–î–∞–π–¥–∂–µ—Å—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω"
        )
    return digest

@app.get("/api/digests/{digest_id}/data")
def get_digest_data(digest_id: str, db: Session = Depends(get_db)):
    """–ü–æ–ª—É—á–∏—Ç—å –ø–æ–ª–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –¥–∞–π–¥–∂–µ—Å—Ç–∞ –≤ JSON —Ñ–æ—Ä–º–∞—Ç–µ"""
    digest = db.query(Digest).filter(Digest.digest_id == digest_id).first()
    if not digest:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="–î–∞–π–¥–∂–µ—Å—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω"
        )
    
    try:
        if digest.digest_data:
            data = json.loads(digest.digest_data)
            return data
        else:
            return {"error": "–î–∞–Ω–Ω—ã–µ –¥–∞–π–¥–∂–µ—Å—Ç–∞ –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç"}
    except json.JSONDecodeError:
        return {"error": "–û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ –¥–∞–Ω–Ω—ã—Ö –¥–∞–π–¥–∂–µ—Å—Ç–∞"}

@app.delete("/api/digests/{digest_id}")
def delete_digest(digest_id: str, db: Session = Depends(get_db)):
    """–£–¥–∞–ª–∏—Ç—å –¥–∞–π–¥–∂–µ—Å—Ç"""
    digest = db.query(Digest).filter(Digest.digest_id == digest_id).first()
    if not digest:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="–î–∞–π–¥–∂–µ—Å—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω"
        )
    
    db.delete(digest)
    db.commit()
    return {"message": "–î–∞–π–¥–∂–µ—Å—Ç —É—Å–ø–µ—à–Ω–æ —É–¥–∞–ª–µ–Ω"}

@app.get("/api/digests/stats/summary")
def get_digests_stats(db: Session = Depends(get_db)):
    """–ü–æ–ª—É—á–∏—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –¥–∞–π–¥–∂–µ—Å—Ç–æ–≤"""
    total_digests = db.query(Digest).count()
    
    if total_digests == 0:
        return {
            "total_digests": 0,
            "avg_posts_per_digest": 0,
            "avg_relevance_rate": 0,
            "total_posts_processed": 0
        }
    
    # –ê–≥—Ä–µ–≥–∏—Ä–æ–≤–∞–Ω–Ω–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
    from sqlalchemy import func as sql_func
    stats = db.query(
        sql_func.avg(Digest.total_posts).label('avg_posts'),
        sql_func.avg(Digest.relevant_posts).label('avg_relevant'),
        sql_func.sum(Digest.total_posts).label('total_posts'),
        sql_func.avg(Digest.avg_importance).label('avg_importance'),
        sql_func.avg(Digest.avg_urgency).label('avg_urgency'),
        sql_func.avg(Digest.avg_significance).label('avg_significance')
    ).first()
    
    return {
        "total_digests": total_digests,
        "avg_posts_per_digest": round(stats.avg_posts or 0, 1),
        "avg_relevance_rate": round((stats.avg_relevant / stats.avg_posts * 100) if stats.avg_posts else 0, 1),
        "total_posts_processed": stats.total_posts or 0,
        "avg_metrics": {
            "importance": round(stats.avg_importance or 0, 1),
            "urgency": round(stats.avg_urgency or 0, 1),
            "significance": round(stats.avg_significance or 0, 1)
        }
    }

# API –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –∏ –ø–æ–¥–ø–∏—Å–æ–∫
@app.post("/api/users", response_model=UserResponse, status_code=status.HTTP_201_CREATED)
def create_or_update_user(user: UserCreate, db: Session = Depends(get_db)):
    """–°–æ–∑–¥–∞—Ç—å –Ω–æ–≤–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏–ª–∏ –æ–±–Ω–æ–≤–∏—Ç—å —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–≥–æ"""
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å
    existing_user = db.query(User).filter(User.telegram_id == user.telegram_id).first()
    
    if existing_user:
        # –û–±–Ω–æ–≤–ª—è–µ–º –¥–∞–Ω–Ω—ã–µ —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        for field, value in user.model_dump().items():
            if hasattr(existing_user, field) and value is not None:
                setattr(existing_user, field, value)
        existing_user.last_activity = func.now()
        db.commit()
        db.refresh(existing_user)
        return existing_user
    else:
        # –°–æ–∑–¥–∞–µ–º –Ω–æ–≤–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        db_user = User(**user.model_dump())
        db_user.last_activity = func.now()
        db.add(db_user)
        db.commit()
        db.refresh(db_user)
        return db_user

@app.get("/api/users/{telegram_id}", response_model=UserResponse)
def get_user(telegram_id: int, db: Session = Depends(get_db)):
    """–ü–æ–ª—É—á–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–æ Telegram ID"""
    user = db.query(User).filter(User.telegram_id == telegram_id).first()
    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω"
        )
    return user

@app.get("/api/users/{telegram_id}/subscriptions", response_model=List[CategoryResponse])
def get_user_subscriptions(telegram_id: int, db: Session = Depends(get_db)):
    """–ü–æ–ª—É—á–∏—Ç—å –ø–æ–¥–ø–∏—Å–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
    user = db.query(User).filter(User.telegram_id == telegram_id).first()
    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω"
        )
    return user.subscribed_categories

@app.post("/api/users/{telegram_id}/subscriptions", response_model=SubscriptionResponse)
def update_user_subscriptions(telegram_id: int, subscription: SubscriptionRequest, db: Session = Depends(get_db)):
    """–û–±–Ω–æ–≤–∏—Ç—å –ø–æ–¥–ø–∏—Å–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
    # –ü–æ–ª—É—á–∞–µ–º –∏–ª–∏ —Å–æ–∑–¥–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    user = db.query(User).filter(User.telegram_id == telegram_id).first()
    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω. –°–Ω–∞—á–∞–ª–∞ —Å–æ–∑–¥–∞–π—Ç–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è."
        )
    
    # –ü–æ–ª—É—á–∞–µ–º –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –ø–æ ID
    categories = db.query(Category).filter(Category.id.in_(subscription.category_ids)).all()
    if len(categories) != len(subscription.category_ids):
        found_ids = [cat.id for cat in categories]
        missing_ids = [cat_id for cat_id in subscription.category_ids if cat_id not in found_ids]
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"–ö–∞—Ç–µ–≥–æ—Ä–∏–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã: {missing_ids}"
        )
    
    # –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ–¥–ø–∏—Å–∫–∏
    user.subscribed_categories = categories
    user.last_activity = func.now()
    db.commit()
    db.refresh(user)
    
    return SubscriptionResponse(
        user_id=user.id,
        subscribed_categories=user.subscribed_categories,
        message=f"–ü–æ–¥–ø–∏—Å–∫–∏ –æ–±–Ω–æ–≤–ª–µ–Ω—ã. –í—ã–±—Ä–∞–Ω–æ –∫–∞—Ç–µ–≥–æ—Ä–∏–π: {len(categories)}"
    )

@app.delete("/api/users/{telegram_id}/subscriptions/{category_id}")
def remove_user_subscription(telegram_id: int, category_id: int, db: Session = Depends(get_db)):
    """–£–¥–∞–ª–∏—Ç—å –ø–æ–¥–ø–∏—Å–∫—É –Ω–∞ –∫–∞—Ç–µ–≥–æ—Ä–∏—é"""
    user = db.query(User).filter(User.telegram_id == telegram_id).first()
    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω"
        )
    
    category = db.query(Category).filter(Category.id == category_id).first()
    if not category:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="–ö–∞—Ç–µ–≥–æ—Ä–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞"
        )
    
    if category in user.subscribed_categories:
        user.subscribed_categories.remove(category)
        user.last_activity = func.now()
        db.commit()
        return {"message": "–ü–æ–¥–ø–∏—Å–∫–∞ —É–¥–∞–ª–µ–Ω–∞"}
    else:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –ø–æ–¥–ø–∏—Å–∞–Ω –Ω–∞ —ç—Ç—É –∫–∞—Ç–µ–≥–æ—Ä–∏—é"
        )

# API –¥–ª—è posts_cache
@app.post("/api/posts/batch", status_code=status.HTTP_201_CREATED)
def create_posts_batch(batch: PostsBatchCreate, db: Session = Depends(get_db)):
    """–ü—Ä–∏–Ω–∏–º–∞–µ—Ç batch –ø–æ—Å—Ç–æ–≤ –æ—Ç userbot –∏ —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç –≤ posts_cache"""
    try:
        created_posts = []
        skipped_posts = []
        
        for post_data in batch.posts:
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ —É–∂–µ —Ç–∞–∫–æ–π –ø–æ—Å—Ç
            existing_post = db.query(PostCache).filter(
                PostCache.channel_telegram_id == post_data.channel_telegram_id,
                PostCache.telegram_message_id == post_data.telegram_message_id
            ).first()
            
            if existing_post:
                skipped_posts.append({
                    "channel_id": post_data.channel_telegram_id,
                    "message_id": post_data.telegram_message_id,
                    "reason": "already_exists"
                })
                continue
            
            # –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π –ø–æ—Å—Ç
            post_dict = post_data.model_dump()
            # –î–æ–±–∞–≤–ª—è–µ–º metadata –æ—Ç userbot - –∏—â–µ–º –ø–æ —Ä–∞–∑–ª–∏—á–Ω—ã–º –∫–ª—é—á–∞–º
            metadata = {}
            if batch.channels_metadata:
                # –ü—ã—Ç–∞–µ–º—Å—è –Ω–∞–π—Ç–∏ metadata –ø–æ —Ä–∞–∑–ª–∏—á–Ω—ã–º –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä–∞–º
                channel_key = None
                for key in batch.channels_metadata.keys():
                    if str(post_data.channel_telegram_id) in key or key == str(post_data.channel_telegram_id):
                        channel_key = key
                        break
                
                if channel_key:
                    metadata = batch.channels_metadata[channel_key]
            
            # JSONB –ø–æ–ª—è —Ç–µ–ø–µ—Ä—å —Å–æ—Ö—Ä–∞–Ω—è—é—Ç—Å—è –Ω–∞–ø—Ä—è–º—É—é –∫–∞–∫ Python –æ–±—ä–µ–∫—Ç—ã
            post_dict["userbot_metadata"] = metadata if metadata else {}
            
            db_post = PostCache(**post_dict)
            db.add(db_post)
            created_posts.append(post_data.telegram_message_id)
        
        db.commit()
        
        return {
            "message": "Batch –æ–±—Ä–∞–±–æ—Ç–∞–Ω —É—Å–ø–µ—à–Ω–æ",
            "timestamp": batch.timestamp,
            "collection_stats": batch.collection_stats,
            "created_posts": len(created_posts),
            "skipped_posts": len(skipped_posts),
            "created_ids": created_posts,
            "skipped_details": skipped_posts
        }
        
    except Exception as e:
        db.rollback()
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –ø–æ—Å—Ç–æ–≤: {str(e)}"
        )

@app.get("/api/posts/cache", response_model=List[PostCacheResponse])
def get_posts_cache(
    skip: int = 0,
    limit: int = 100,
    channel_telegram_id: Optional[int] = None,
    processing_status: Optional[str] = None,
    search: Optional[str] = None,
    date_from: Optional[str] = None,
    date_to: Optional[str] = None,
    sort_by: str = "collected_at",
    sort_order: str = "desc",
    db: Session = Depends(get_db)
):
    """–ü–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –ø–æ—Å—Ç–æ–≤ –∏–∑ cache —Å —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω–æ–π —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–µ–π"""
    from datetime import datetime
    
    query = db.query(PostCache)
    
    # –§–∏–ª—å—Ç—Ä –ø–æ –∫–∞–Ω–∞–ª—É
    if channel_telegram_id:
        query = query.filter(PostCache.channel_telegram_id == channel_telegram_id)
    
    # –§–∏–ª—å—Ç—Ä –ø–æ —Å—Ç–∞—Ç—É—Å—É –æ–±—Ä–∞–±–æ—Ç–∫–∏
    if processing_status:
        query = query.filter(PostCache.processing_status == processing_status)
    
    # –ü–æ–∏—Å–∫ –ø–æ —Å–æ–¥–µ—Ä–∂–∏–º–æ–º—É
    if search:
        search_pattern = f"%{search}%"
        query = query.filter(
            PostCache.content.ilike(search_pattern) |
            PostCache.title.ilike(search_pattern)
        )
    
    # –§–∏–ª—å—Ç—Ä –ø–æ –¥–∞—Ç–µ
    if date_from:
        try:
            date_from_obj = datetime.fromisoformat(date_from.replace('Z', '+00:00'))
            query = query.filter(PostCache.post_date >= date_from_obj)
        except ValueError:
            pass
    
    if date_to:
        try:
            date_to_obj = datetime.fromisoformat(date_to.replace('Z', '+00:00'))
            query = query.filter(PostCache.post_date <= date_to_obj)
        except ValueError:
            pass
    
    # –°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞
    sort_column = getattr(PostCache, sort_by, PostCache.collected_at)
    if sort_order.lower() == "desc":
        query = query.order_by(sort_column.desc())
    else:
        query = query.order_by(sort_column.asc())
    
    posts = query.offset(skip).limit(limit).all()
    return posts

@app.get("/api/posts/stats")
def get_posts_stats(db: Session = Depends(get_db)):
    """–ü–æ–ª—É—á–∏—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É posts_cache"""
    from sqlalchemy import func as sql_func
    
    # –û–±—â–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
    total_posts = db.query(PostCache).count()
    
    # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ –∫–∞–Ω–∞–ª–∞–º —Å –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–µ–π
    channel_stats = db.query(
        PostCache.channel_telegram_id,
        sql_func.count(PostCache.id).label('posts_count'),
        sql_func.max(PostCache.collected_at).label('last_collected'),
        sql_func.avg(PostCache.views).label('avg_views'),
        sql_func.max(PostCache.views).label('max_views')
    ).group_by(
        PostCache.channel_telegram_id
    ).all()
    
    # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ —Å—Ç–∞—Ç—É—Å–∞–º –æ–±—Ä–∞–±–æ—Ç–∫–∏
    status_stats = db.query(
        PostCache.processing_status,
        sql_func.count(PostCache.id).label('count')
    ).group_by(PostCache.processing_status).all()
    
    # –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –∫–∞–Ω–∞–ª–∞—Ö –∏–∑ –æ—Å–Ω–æ–≤–Ω–æ–π —Ç–∞–±–ª–∏—Ü—ã
    channel_info = {}
    for stat in channel_stats:
        channel = db.query(Channel).filter(Channel.telegram_id == stat.channel_telegram_id).first()
        if channel:
            channel_info[stat.channel_telegram_id] = {
                "title": channel.title,
                "username": channel.username,
                "categories": [cat.name for cat in channel.categories]
            }
    
    return {
        "total_posts": total_posts,
        "channels": [
            {
                "telegram_id": stat.channel_telegram_id,
                "posts_count": stat.posts_count,
                "last_collected": stat.last_collected,
                "avg_views": round(stat.avg_views or 0, 0),
                "max_views": stat.max_views or 0,
                "title": channel_info.get(stat.channel_telegram_id, {}).get("title", f"Channel {stat.channel_telegram_id}"),
                "username": channel_info.get(stat.channel_telegram_id, {}).get("username"),
                "categories": channel_info.get(stat.channel_telegram_id, {}).get("categories", [])
            }
            for stat in channel_stats
        ],
        "processing_status": [
            {
                "status": stat.processing_status,
                "count": stat.count
            }
            for stat in status_stats
        ]
    }

@app.get("/api/posts/cache/count")
def get_posts_cache_count(
    channel_telegram_id: Optional[int] = None,
    processing_status: Optional[str] = None,
    search: Optional[str] = None,
    date_from: Optional[str] = None,
    date_to: Optional[str] = None,
    db: Session = Depends(get_db)
):
    """–ü–æ–ª—É—á–∏—Ç—å –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ—Å—Ç–æ–≤ —Å —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–µ–π (–¥–ª—è –ø–∞–≥–∏–Ω–∞—Ü–∏–∏)"""
    from datetime import datetime
    
    query = db.query(PostCache)
    
    if channel_telegram_id:
        query = query.filter(PostCache.channel_telegram_id == channel_telegram_id)
    
    if processing_status:
        query = query.filter(PostCache.processing_status == processing_status)
    
    if search:
        search_pattern = f"%{search}%"
        query = query.filter(
            PostCache.content.ilike(search_pattern) |
            PostCache.title.ilike(search_pattern)
        )
    
    if date_from:
        try:
            date_from_obj = datetime.fromisoformat(date_from.replace('Z', '+00:00'))
            query = query.filter(PostCache.post_date >= date_from_obj)
        except ValueError:
            pass
    
    if date_to:
        try:
            date_to_obj = datetime.fromisoformat(date_to.replace('Z', '+00:00'))
            query = query.filter(PostCache.post_date <= date_to_obj)
        except ValueError:
            pass
    
    total_count = query.count()
    return {"total_count": total_count}

@app.get("/api/posts/cache/size")
def get_posts_cache_size(
    channel_telegram_id: Optional[int] = None,
    db: Session = Depends(get_db)
):
    """–ü–æ–ª—É—á–∏—Ç—å —Ä–∞–∑–º–µ—Ä posts_cache –≤ –ú–ë (–æ–±—â–∏–π –∏–ª–∏ –ø–æ –∫–∞–Ω–∞–ª—É)"""
    try:
        if channel_telegram_id:
            size_mb = get_filtered_data_size([channel_telegram_id])
        else:
            size_mb = get_filtered_data_size()
        
        # –û—Ç–ª–∞–¥–æ—á–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è
        if not channel_telegram_id:
            # –ó–∞–ø—Ä–æ—Å –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏ - –ø—Ä—è–º–æ –≤ endpoint
            result = db.execute(text("SELECT pg_size_pretty(pg_total_relation_size('posts_cache'))")).fetchone()
            debug_size_str = result[0] if result else "unknown"
            print(f"DEBUG: pg_size_pretty result for posts_cache: '{debug_size_str}'")
        
        return {
            "size_mb": size_mb,
            "channel_telegram_id": channel_telegram_id
        }
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Ä–∞–∑–º–µ—Ä–∞ –¥–∞–Ω–Ω—ã—Ö: {str(e)}"
        )

@app.delete("/api/database/clear")
def clear_database(
    confirm: bool = False,
    db: Session = Depends(get_db)
):
    """–ö–†–ò–¢–ò–ß–ï–°–ö–û–ï –î–ï–ô–°–¢–í–ò–ï: –û—á–∏—Å—Ç–∏—Ç—å –≤—Å—é –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö"""
    if not confirm:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="–î–ª—è –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è –∫—Ä–∏—Ç–∏—á–µ—Å–∫–æ–≥–æ –¥–µ–π—Å—Ç–≤–∏—è –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –ø–µ—Ä–µ–¥–∞—Ç—å –ø–∞—Ä–∞–º–µ—Ç—Ä confirm=true"
        )
    
    try:
        # –ü–æ–ª—É—á–∞–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –ø–µ—Ä–µ–¥ —É–¥–∞–ª–µ–Ω–∏–µ–º
        posts_count = db.query(PostCache).count()
        digests_count = db.query(Digest).count()
        
        # –£–¥–∞–ª—è–µ–º –≤—Å–µ –ø–æ—Å—Ç—ã
        db.query(PostCache).delete()
        
        # –£–¥–∞–ª—è–µ–º –≤—Å–µ –¥–∞–π–¥–∂–µ—Å—Ç—ã  
        db.query(Digest).delete()
        
        # –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Å–≤—è–∑–∏ –∫–∞–Ω–∞–ª–æ–≤ —Å –∫–∞—Ç–µ–≥–æ—Ä–∏—è–º–∏ (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)
        # db.execute(text("TRUNCATE TABLE channel_categories"))
        
        db.commit()
        
        return {
            "message": "–ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö —É—Å–ø–µ—à–Ω–æ –æ—á–∏—â–µ–Ω–∞",
            "deleted_posts": posts_count,
            "deleted_digests": digests_count,
            "warning": "–≠—Ç–æ –¥–µ–π—Å—Ç–≤–∏–µ –Ω–µ–æ–±—Ä–∞—Ç–∏–º–æ!"
        }
        
    except Exception as e:
        db.rollback()
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"–û—à–∏–±–∫–∞ –æ—á–∏—Å—Ç–∫–∏ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö: {str(e)}"
        )

@app.delete("/api/posts/orphans")
def cleanup_orphan_posts(
    confirm: bool = False,
    db: Session = Depends(get_db)
):
    """–£–¥–∞–ª–∏—Ç—å –ø–æ—Å—Ç—ã –æ—Ç –∫–∞–Ω–∞–ª–æ–≤, –∫–æ—Ç–æ—Ä—ã—Ö –±–æ–ª—å—à–µ –Ω–µ—Ç –≤ —Å–∏—Å—Ç–µ–º–µ (orphan cleanup)"""
    if not confirm:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="–î–ª—è –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è –¥–µ–π—Å—Ç–≤–∏—è –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –ø–µ—Ä–µ–¥–∞—Ç—å –ø–∞—Ä–∞–º–µ—Ç—Ä confirm=true"
        )
    
    try:
        # –ü–æ–ª—É—á–∞–µ–º —Å–ø–∏—Å–æ–∫ –∞–∫—Ç–∏–≤–Ω—ã—Ö telegram_id –∫–∞–Ω–∞–ª–æ–≤
        active_channel_ids = db.query(Channel.telegram_id).filter(Channel.is_active == True).all()
        active_ids_set = {row[0] for row in active_channel_ids}
        
        # –ù–∞—Ö–æ–¥–∏–º –ø–æ—Å—Ç—ã –æ—Ç –Ω–µ—Å—É—â–µ—Å—Ç–≤—É—é—â–∏—Ö –∫–∞–Ω–∞–ª–æ–≤
        orphan_posts_query = db.query(PostCache).filter(
            ~PostCache.channel_telegram_id.in_(active_ids_set)
        )
        
        # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –¥–æ —É–¥–∞–ª–µ–Ω–∏—è
        orphan_count = orphan_posts_query.count()
        
        if orphan_count == 0:
            return {
                "message": "Orphan –ø–æ—Å—Ç–æ–≤ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ",
                "deleted_posts": 0,
                "active_channels": len(active_ids_set)
            }
        
        # –ü–æ–ª—É—á–∞–µ–º –¥–µ—Ç–∞–ª–∏ orphan –∫–∞–Ω–∞–ª–æ–≤ –¥–ª—è –æ—Ç—á–µ—Ç–∞
        orphan_channels_stats = db.query(
            PostCache.channel_telegram_id,
            sql_func.count(PostCache.id).label('posts_count')
        ).filter(
            ~PostCache.channel_telegram_id.in_(active_ids_set)
        ).group_by(PostCache.channel_telegram_id).all()
        
        # –£–¥–∞–ª—è–µ–º orphan –ø–æ—Å—Ç—ã
        deleted_count = orphan_posts_query.delete(synchronize_session=False)
        db.commit()
        
        return {
            "message": f"–£—Å–ø–µ—à–Ω–æ —É–¥–∞–ª–µ–Ω–æ {deleted_count} orphan –ø–æ—Å—Ç–æ–≤",
            "deleted_posts": deleted_count,
            "orphan_channels": [
                {
                    "telegram_id": stat.channel_telegram_id,
                    "deleted_posts": stat.posts_count
                }
                for stat in orphan_channels_stats
            ],
            "active_channels": len(active_ids_set)
        }
        
    except Exception as e:
        db.rollback()
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"–û—à–∏–±–∫–∞ –æ—á–∏—Å—Ç–∫–∏ orphan –ø–æ—Å—Ç–æ–≤: {str(e)}"
        )

# –°–æ–∑–¥–∞–Ω–∏–µ —Ç–∞–±–ª–∏—Ü –ë–î - –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è –≤ –∫–æ–Ω—Ü–µ –ø–æ—Å–ª–µ –≤—Å–µ—Ö –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–π
print("üîß –°–æ–∑–¥–∞–Ω–∏–µ —Ç–∞–±–ª–∏—Ü –≤ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö...")
try:
    Base.metadata.create_all(bind=engine)
    print("‚úÖ –¢–∞–±–ª–∏—Ü—ã —Å–æ–∑–¥–∞–Ω—ã —É—Å–ø–µ—à–Ω–æ")
except Exception as e:
    print(f"‚ùå –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è —Ç–∞–±–ª–∏—Ü: {e}")

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000) 